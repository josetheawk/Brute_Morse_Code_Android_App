
================================================================================
BRUTE MORSE CODE - ANDROID APPLICATION SOURCE CODE
================================================================================

Generated: 2025-10-16 23:04:10
Project: Brute Morse Code Android App
Purpose: Complete source code listing for Claude AI analysis

This file contains the complete source code of the Brute Morse Code Android
application, organized for easy review and analysis.

PROJECT STRUCTURE:
- Source Code: Kotlin files implementing app logic
- Configuration: Gradle build files, manifest
- Resources: XML layouts, strings, themes
- Documentation: README and other docs

================================================================================


================================================================================
ANDROID MANIFEST
================================================================================
Files in this section: 1
================================================================================


--------------------------------------------------------------------------------
FILE: app\src\main\AndroidManifest.xml
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />

    <application
        android:name=".BruteMorseApp"
        android:allowBackup="true"
        android:icon="@drawable/ic_notification"
        android:label="@string/app_name"
        android:roundIcon="@drawable/ic_notification"
        android:supportsRtl="true"
        android:theme="@style/Theme.BruteMorse">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:label="@string/app_name"
            android:screenOrientation="unspecified"
            android:theme="@style/Theme.BruteMorse">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".audio.PlaybackService"
            android:exported="false"
            android:foregroundServiceType="mediaPlayback" />
    </application>

</manifest>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\AndroidManifest.xml
--------------------------------------------------------------------------------


================================================================================
GRADLE CONFIGURATION
================================================================================
Files in this section: 4
================================================================================


--------------------------------------------------------------------------------
FILE: app\build.gradle.kts
--------------------------------------------------------------------------------

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.kotlin.plugin.serialization")
}

android {
    namespace = "com.example.brutemorse"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.example.brutemorse"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables.useSupportLibrary = true
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }

    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.6.8"
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.05.00")

    implementation(composeBom)
    androidTestImplementation(composeBom)

    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.4")
    implementation("androidx.activity:activity-compose:1.9.3")
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    
    // ADD THIS LINE - Extended Material Icons (includes AutoMirrored icons)
    implementation("androidx.compose.material:material-icons-extended-android")

    implementation("com.google.android.material:material:1.12.0")
    implementation("androidx.navigation:navigation-compose:2.7.7")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.datastore:datastore-preferences:1.1.1")
    implementation("androidx.media3:media3-exoplayer:1.4.1")
    implementation("androidx.media3:media3-session:1.4.1")
    implementation("com.google.android.material:material:1.12.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3")

    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")

    androidTestImplementation("androidx.test.ext:junit:1.2.1")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
}

--------------------------------------------------------------------------------
END OF FILE: app\build.gradle.kts
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: build.gradle.kts
--------------------------------------------------------------------------------

plugins {
    id("com.android.application") version "8.13.0" apply false
    id("org.jetbrains.kotlin.android") version "2.0.20" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.20" apply false
    id("org.jetbrains.kotlin.plugin.serialization") version "2.0.20" apply false
}

--------------------------------------------------------------------------------
END OF FILE: build.gradle.kts
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: gradle.properties
--------------------------------------------------------------------------------

# Enable AndroidX support libraries across the project.
android.useAndroidX=true
# Set to true initially to ensure any legacy support library dependencies are migrated via Jetifier.
android.enableJetifier=true

# Increased Gradle daemon memory to avoid GC thrashing during builds.
org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8

# Keep the daemon from exiting immediately during intensive builds.
org.gradle.daemon.performance.disable-logging=true

--------------------------------------------------------------------------------
END OF FILE: gradle.properties
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: settings.gradle.kts
--------------------------------------------------------------------------------

pluginManagement {
    repositories {
        gradlePluginPortal()
        google()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "Brute_Morse_Code_Android_App"
include(":app")

--------------------------------------------------------------------------------
END OF FILE: settings.gradle.kts
--------------------------------------------------------------------------------


================================================================================
SOURCE CODE
================================================================================
Files in this section: 28
================================================================================


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\audio\MorseAudioPlayer.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.audio

import android.content.Context
import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioManager
import android.media.AudioTrack
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlin.math.sin

class MorseAudioPlayer(private val context: Context) {

    private var toneTrack: AudioTrack? = null
    private var toneBuffer: ShortArray? = null
    private val sampleRate = 44100
    private var isPlaying = false

    suspend fun playMorsePattern(
        pattern: String,
        frequencyHz: Int,
        wpm: Int
    ) = withContext(Dispatchers.IO) {
        val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
        val previousMode = audioManager.mode
        val previousSpeakerphone = audioManager.isSpeakerphoneOn

        audioManager.mode = AudioManager.MODE_IN_COMMUNICATION
        audioManager.isSpeakerphoneOn = true

        try {
            val timing = com.example.brutemorse.data.MorseTimingConfig(wpm)
            val totalDurationMs = com.example.brutemorse.data.MorseTimingConfig.calculateDuration(pattern, timing)
            val totalSamples = (totalDurationMs * sampleRate / 1000).toInt()

            if (totalSamples <= 0) {
                android.util.Log.w("MorseAudioPlayer", "Invalid pattern duration: $totalDurationMs ms")
                return@withContext
            }

            val samples = ShortArray(totalSamples)
            var currentSampleOffset = 0

            pattern.forEach { char ->
                val elementDurationMs = when (char) {
                    '.', '·', '•' -> timing.ditMs
                    '-', '−', '–', '—' -> timing.dahMs
                    ' ' -> timing.interCharacterGapMs
                    else -> 0L
                }

                if (elementDurationMs > 0 && char != ' ') {
                    val elementSamples = (elementDurationMs * sampleRate / 1000).toInt()

                    if (currentSampleOffset + elementSamples > samples.size) {
                        android.util.Log.w("MorseAudioPlayer", "Pattern too long at offset $currentSampleOffset, truncating")
                        return@forEach
                    }

                    generateTone(samples, currentSampleOffset, elementSamples, frequencyHz, sampleRate)
                    currentSampleOffset += elementSamples
                } else if (char == ' ') {
                    val gapSamples = (elementDurationMs * sampleRate / 1000).toInt()
                    currentSampleOffset += gapSamples

                    if (currentSampleOffset > samples.size) {
                        android.util.Log.w("MorseAudioPlayer", "Pattern overflow during gap, truncating")
                        currentSampleOffset = samples.size
                        return@forEach
                    }
                }

                val gapSamples = (timing.intraCharacterGapMs * sampleRate / 1000).toInt()
                currentSampleOffset += gapSamples

                if (currentSampleOffset > samples.size) {
                    android.util.Log.w("MorseAudioPlayer", "Pattern overflow during intra-char gap")
                    currentSampleOffset = samples.size
                    return@forEach
                }
            }

            playAudioBuffer(samples, sampleRate)
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error playing morse pattern", e)
        } finally {
            audioManager.mode = previousMode
            audioManager.isSpeakerphoneOn = previousSpeakerphone
        }
    }

    fun startContinuousTone(frequencyHz: Int) {
        if (toneTrack == null) {
            initializeToneTrack(frequencyHz)
        }

        isPlaying = true
        try {
            toneTrack?.play()
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error starting tone", e)
            releaseToneTrack()
            initializeToneTrack(frequencyHz)
            toneTrack?.play()
        }
    }

    fun stopContinuousTone() {
        isPlaying = false
        try {
            toneTrack?.pause()
            toneTrack?.flush()
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error stopping tone", e)
        }
    }

    private fun initializeToneTrack(frequencyHz: Int) {
        try {
            val minBufferSize = AudioTrack.getMinBufferSize(
                sampleRate,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )

            val bufferSamples = sampleRate / 2
            toneBuffer = ShortArray(bufferSamples)

            val samplesPerCycle = sampleRate.toDouble() / frequencyHz

            for (i in 0 until bufferSamples) {
                val phase = (2.0 * Math.PI * i) / samplesPerCycle
                toneBuffer!![i] = (sin(phase) * Short.MAX_VALUE * 0.6).toInt().toShort()
            }

            toneTrack = AudioTrack.Builder()
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .build()
                )
                .setAudioFormat(
                    AudioFormat.Builder()
                        .setSampleRate(sampleRate)
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                        .build()
                )
                .setBufferSizeInBytes(maxOf(minBufferSize * 4, bufferSamples * 2))
                .setTransferMode(AudioTrack.MODE_STATIC)
                .build()

            toneTrack?.write(toneBuffer!!, 0, bufferSamples)
            toneTrack?.setLoopPoints(0, bufferSamples, -1)
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error initializing tone track", e)
            releaseToneTrack()
        }
    }

    private fun releaseToneTrack() {
        try {
            toneTrack?.stop()
            toneTrack?.release()
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error releasing tone track", e)
        }
        toneTrack = null
        toneBuffer = null
    }

    private fun generateTone(
        buffer: ShortArray,
        startOffset: Int,
        numSamples: Int,
        frequencyHz: Int,
        sampleRate: Int
    ) {
        if (startOffset < 0 || startOffset >= buffer.size) {
            android.util.Log.e("MorseAudioPlayer", "Invalid startOffset: $startOffset")
            return
        }

        val fadeMs = 3
        val fadeSamples = (fadeMs * sampleRate / 1000).coerceAtMost(numSamples / 2)

        val maxSamples = (buffer.size - startOffset).coerceAtMost(numSamples)

        for (i in 0 until maxSamples) {
            val angle = 2.0 * Math.PI * i / (sampleRate / frequencyHz.toDouble())
            var amplitude = 0.5

            if (i < fadeSamples) {
                amplitude *= (i.toDouble() / fadeSamples)
            }
            if (i > maxSamples - fadeSamples) {
                amplitude *= ((maxSamples - i).toDouble() / fadeSamples)
            }

            buffer[startOffset + i] = (sin(angle) * Short.MAX_VALUE * amplitude).toInt().toShort()
        }
    }

    private suspend fun playAudioBuffer(samples: ShortArray, sampleRate: Int) {
        var track: AudioTrack? = null
        try {
            val minBufferSize = AudioTrack.getMinBufferSize(
                sampleRate,
                AudioFormat.CHANNEL_OUT_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )

            track = AudioTrack.Builder()
                .setAudioAttributes(
                    AudioAttributes.Builder()
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                        .build()
                )
                .setAudioFormat(
                    AudioFormat.Builder()
                        .setSampleRate(sampleRate)
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                        .build()
                )
                .setBufferSizeInBytes(maxOf(minBufferSize, samples.size * 2))
                .setTransferMode(AudioTrack.MODE_STREAM)
                .build()

            track.play()

            var offset = 0
            while (offset < samples.size) {
                val written = track.write(samples, offset, samples.size - offset)
                if (written < 0) {
                    android.util.Log.e("MorseAudioPlayer", "Error writing audio: $written")
                    break
                }
                offset += written
            }

            val durationMs = samples.size * 1000L / sampleRate
            kotlinx.coroutines.delay(durationMs)

            track.stop()
        } catch (e: Exception) {
            android.util.Log.e("MorseAudioPlayer", "Error playing audio buffer", e)
        } finally {
            try {
                track?.release()
            } catch (e: Exception) {
                android.util.Log.e("MorseAudioPlayer", "Error releasing track", e)
            }
        }
    }

    fun release() {
        releaseToneTrack()
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\audio\MorseAudioPlayer.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\audio\MorseInputDetector.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.audio

import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.SystemClock
import com.example.brutemorse.model.MorseDefinitions
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlin.math.max
import kotlin.math.sqrt

data class MorseInputEvent(
    val pattern: String,  // e.g., "• —"
    val durationMillis: List<Long>,  // timing of each element
    val character: String?  // decoded character or null if invalid
)

data class AudioMetrics(
    val currentRMS: Float,
    val noiseFloor: Float,
    val threshold: Float,
    val isKeyDown: Boolean
)

class MorseInputDetector(private val wpm: Int = 25) {
    private val _currentInput = MutableStateFlow("")
    val currentInput: StateFlow<String> = _currentInput.asStateFlow()

    private var keyDownTime = 0L
    private var lastKeyUpTime = 0L
    private val timings = mutableListOf<Long>()

    // Use centralized timing configuration
    private val timing = com.example.brutemorse.data.MorseTimingConfig(wpm)
    private val ditMax = (timing.ditMs * 1.5).toLong()  // 1.5 units = boundary between dit and dah
    private val interCharGap = timing.interCharacterGapMs

    // Audio detection
    private var audioRecord: AudioRecord? = null
    private var isListening = false
    private var isKeyCurrentlyDown = false
    private val sampleRate = 16000
    private var noiseFloor = 100.0  // Even lower starting noise floor for emulator
    private val noiseAlpha = 0.02  // Faster adaptation for noise floor
    private var pressFactor = 2.5  // Even more sensitive threshold
    private val debounceMs = 10  // Even shorter debounce

    // Expose current audio metrics for testing
    private var currentRMS = 0.0

    fun getAudioMetrics(): AudioMetrics {
        return AudioMetrics(
            currentRMS = currentRMS.toFloat(),
            noiseFloor = noiseFloor.toFloat(),
            threshold = (noiseFloor * pressFactor).toFloat(),
            isKeyDown = isKeyCurrentlyDown
        )
    }

    fun updateSensitivity(sensitivity: Float) {
        pressFactor = sensitivity.toDouble()
    }

    fun startAudioListening() {
        if (isListening) return

        val bufferSize = AudioRecord.getMinBufferSize(
            sampleRate,
            AudioFormat.CHANNEL_IN_MONO,
            AudioFormat.ENCODING_PCM_16BIT
        )

        try {
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.DEFAULT,
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                bufferSize
            )

            audioRecord?.startRecording()
            isListening = true

            // Start monitoring audio in background
            Thread {
                val buffer = ShortArray(bufferSize)
                var lastChange = SystemClock.elapsedRealtime()
                var sampleCount = 0

                while (isListening) {
                    val read = audioRecord?.read(buffer, 0, bufferSize) ?: 0
                    if (read > 0) {
                        // Calculate RMS amplitude
                        var sum = 0.0
                        for (i in 0 until read) {
                            val v = buffer[i].toDouble()
                            sum += v * v
                        }
                        val rms = sqrt(sum / read)
                        currentRMS = rms  // Store for metrics

                        // Adaptive noise floor - only adapt when clearly silent
                        val threshold = noiseFloor * pressFactor
                        if (rms < threshold * 0.5) {
                            noiseFloor = (1 - noiseAlpha) * noiseFloor + noiseAlpha * rms
                        }

                        // Debug logging every 100 samples
                        sampleCount++
                        if (sampleCount % 100 == 0) {
                            android.util.Log.d("MorseInputDetector",
                                "RMS: $rms, Threshold: $threshold, NoiseFloor: $noiseFloor, Pressed: $isKeyCurrentlyDown")
                        }

                        // Detect key press/release based on amplitude with debounce
                        val now = SystemClock.elapsedRealtime()
                        val wantPressed = rms > threshold

                        if (wantPressed != isKeyCurrentlyDown && (now - lastChange) > debounceMs) {
                            isKeyCurrentlyDown = wantPressed
                            lastChange = now

                            android.util.Log.d("MorseInputDetector",
                                "Key state changed: ${if (wantPressed) "DOWN" else "UP"}, RMS: $rms")

                            if (isKeyCurrentlyDown) {
                                onKeyDown()
                            } else {
                                onKeyUp()
                            }
                        }
                    }
                }
            }.start()
        } catch (e: SecurityException) {
            // Permission not granted
            e.printStackTrace()
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    fun stopAudioListening() {
        isListening = false
        try {
            audioRecord?.stop()
            audioRecord?.release()
        } catch (e: Exception) {
            e.printStackTrace()
        }
        audioRecord = null
    }

    // For screen tap fallback
    fun onKeyDown() {
        keyDownTime = SystemClock.elapsedRealtime()
        android.util.Log.d("MorseInputDetector", "onKeyDown called at $keyDownTime")
    }

    fun onKeyUp() {
        val now = SystemClock.elapsedRealtime()
        android.util.Log.d("MorseInputDetector", "onKeyUp called at $now")
        if (keyDownTime > 0) {
            val duration = now - keyDownTime
            timings.add(duration)

            // Determine if dit or dah - using nice symbols
            val symbol = if (duration < ditMax) "•" else "—"
            _currentInput.value += symbol

            android.util.Log.d("MorseInputDetector",
                "Key held for ${duration}ms, symbol: $symbol, ditMax: $ditMax")

            lastKeyUpTime = now
            keyDownTime = 0
        }
    }

    fun checkCompletion(completionTimeoutMs: Long = interCharGap): MorseInputEvent? {
        val now = SystemClock.elapsedRealtime()

        // If enough time has passed since last key up, consider it complete
        if (lastKeyUpTime > 0 && (now - lastKeyUpTime) > completionTimeoutMs) {
            val pattern = _currentInput.value
            if (pattern.isNotEmpty()) {
                // Convert display symbols back to standard morse for lookup
                val standardPattern = pattern
                    .replace("•", ".")
                    .replace("—", "-")

                val decoded = MorseDefinitions.morseMap.entries
                    .firstOrNull { it.value == standardPattern }?.key

                val event = MorseInputEvent(
                    pattern = pattern,  // Keep the nice display symbols
                    durationMillis = timings.toList(),
                    character = decoded
                )

                // Reset for next character
                reset()
                return event
            }
        }
        return null
    }

    fun reset() {
        _currentInput.value = ""
        timings.clear()
        keyDownTime = 0
        lastKeyUpTime = 0
    }

    fun forceComplete(): MorseInputEvent? {
        val pattern = _currentInput.value
        if (pattern.isNotEmpty()) {
            val standardPattern = pattern
                .replace("•", ".")
                .replace("—", "-")

            val decoded = MorseDefinitions.morseMap.entries
                .firstOrNull { it.value == standardPattern }?.key

            val event = MorseInputEvent(
                pattern = pattern,
                durationMillis = timings.toList(),
                character = decoded
            )
            reset()
            return event
        }
        return null
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\audio\MorseInputDetector.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\audio\PlaybackService.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.audio

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Intent
import android.os.Build
import android.os.IBinder
import androidx.core.app.NotificationCompat
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.session.MediaSession
import com.example.brutemorse.R

class PlaybackService : Service() {

    private lateinit var player: ExoPlayer
    private lateinit var mediaSession: MediaSession

    override fun onCreate() {
        super.onCreate()
        player = ExoPlayer.Builder(this).build()
        mediaSession = MediaSession.Builder(this, player).build()
        createNotificationChannel()
        startForeground(NOTIFICATION_ID, buildNotification())
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        if (!player.isPlaying) {
            player.playWhenReady = false
        }
        return START_STICKY
    }

    override fun onDestroy() {
        super.onDestroy()
        mediaSession.release()
        player.release()
    }

    override fun onBind(intent: Intent?): IBinder? = null

    private fun buildNotification(): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(getString(R.string.app_name))
            .setContentText("Passive immersion active")
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Morse Immersion",
                NotificationManager.IMPORTANCE_LOW
            )
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }
    }

    companion object {
        private const val CHANNEL_ID = "brute_morse_channel"
        private const val NOTIFICATION_ID = 73
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\audio\PlaybackService.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\audio\TextToSpeechPlayer.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.audio

import android.content.Context
import android.speech.tts.TextToSpeech
import android.speech.tts.UtteranceProgressListener
import kotlinx.coroutines.delay
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withTimeoutOrNull
import java.util.Locale
import kotlin.coroutines.resume

class TextToSpeechPlayer(private val context: Context) {
    private var tts: TextToSpeech? = null
    private var isInitialized = false
    private var isInitializing = false
    private val initTimeout = 5000L

    init {
        initializeTTS()
    }

    private fun initializeTTS() {
        if (isInitializing || isInitialized) return

        isInitializing = true
        try {
            tts = TextToSpeech(context) { status ->
                isInitializing = false
                if (status == TextToSpeech.SUCCESS) {
                    val result = tts?.setLanguage(Locale.US)
                    if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                        android.util.Log.e("TextToSpeechPlayer", "Language not supported")
                        isInitialized = false
                    } else {
                        tts?.setSpeechRate(0.9f)
                        isInitialized = true
                        android.util.Log.d("TextToSpeechPlayer", "TTS initialized successfully")
                    }
                } else {
                    android.util.Log.e("TextToSpeechPlayer", "TTS initialization failed with status: $status")
                    isInitialized = false
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("TextToSpeechPlayer", "Error initializing TTS", e)
            isInitializing = false
            isInitialized = false
        }
    }

    suspend fun speak(text: String): Boolean {
        if (text.isBlank()) {
            android.util.Log.w("TextToSpeechPlayer", "Attempted to speak blank text")
            return false
        }

        if (!isInitialized) {
            android.util.Log.w("TextToSpeechPlayer", "TTS not initialized, attempting to initialize")

            if (!isInitializing) {
                initializeTTS()
            }

            val initWaitResult = withTimeoutOrNull(initTimeout) {
                var waited = 0L
                while (!isInitialized && waited < initTimeout) {
                    delay(100L)
                    waited += 100L
                }
                isInitialized
            }

            if (initWaitResult != true) {
                android.util.Log.e("TextToSpeechPlayer", "TTS initialization timed out or failed")
                return false
            }
        }

        return suspendCancellableCoroutine { continuation ->
            if (!isInitialized || tts == null) {
                android.util.Log.e("TextToSpeechPlayer", "TTS still not available after initialization attempt")
                if (continuation.isActive) {
                    continuation.resume(false)
                }
                return@suspendCancellableCoroutine
            }

            val utteranceId = "utterance_${System.currentTimeMillis()}"

            tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {
                override fun onStart(utteranceId: String?) {
                    android.util.Log.d("TextToSpeechPlayer", "Speech started: $utteranceId")
                }

                override fun onDone(utteranceId: String?) {
                    android.util.Log.d("TextToSpeechPlayer", "Speech completed: $utteranceId")
                    if (continuation.isActive) {
                        continuation.resume(true)
                    }
                }

                override fun onError(utteranceId: String?) {
                    android.util.Log.e("TextToSpeechPlayer", "Speech error: $utteranceId")
                    if (continuation.isActive) {
                        continuation.resume(false)
                    }
                }

                @Deprecated("Deprecated in API level 21")
                override fun onError(utteranceId: String?, errorCode: Int) {
                    android.util.Log.e("TextToSpeechPlayer", "Speech error: $utteranceId, code: $errorCode")
                    if (continuation.isActive) {
                        continuation.resume(false)
                    }
                }
            })

            try {
                val result = tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, utteranceId)

                if (result != TextToSpeech.SUCCESS) {
                    android.util.Log.e("TextToSpeechPlayer", "speak() returned failure: $result")
                    if (continuation.isActive) {
                        continuation.resume(false)
                    }
                }
            } catch (e: Exception) {
                android.util.Log.e("TextToSpeechPlayer", "Exception during speak()", e)
                if (continuation.isActive) {
                    continuation.resume(false)
                }
            }

            continuation.invokeOnCancellation {
                try {
                    tts?.stop()
                    android.util.Log.d("TextToSpeechPlayer", "Speech cancelled")
                } catch (e: Exception) {
                    android.util.Log.e("TextToSpeechPlayer", "Error stopping TTS on cancellation", e)
                }
            }
        }
    }

    fun isTTSInitialized(): Boolean = isInitialized

    fun release() {
        try {
            tts?.stop()
            tts?.shutdown()
            android.util.Log.d("TextToSpeechPlayer", "TTS released")
        } catch (e: Exception) {
            android.util.Log.e("TextToSpeechPlayer", "Error releasing TTS", e)
        } finally {
            tts = null
            isInitialized = false
            isInitializing = false
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\audio\TextToSpeechPlayer.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\BruteMorseApp.kt
--------------------------------------------------------------------------------

package com.example.brutemorse

import android.app.Application
import com.example.brutemorse.data.SessionRepository
import com.example.brutemorse.data.SettingsRepository

class BruteMorseApp : Application() {
    lateinit var settingsRepository: SettingsRepository
        private set
    lateinit var sessionRepository: SessionRepository
        private set

    override fun onCreate() {
        super.onCreate()
        settingsRepository = SettingsRepository(applicationContext)
        sessionRepository = SessionRepository(settingsRepository)
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\BruteMorseApp.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\data\MorseTimingConfig.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.data

/**
 * Centralized Morse code timing configuration based on WPM.
 * All timing values follow standard Morse code conventions.
 *
 * Standard timing:
 * - 1 dit = base unit
 * - 1 dah = 3 dits
 * - Inter-element gap (within character) = 1 dit
 * - Inter-character gap = 3 dits
 * - Inter-word gap = 7 dits
 */
data class MorseTimingConfig(
    val wpm: Int
) {
    // Base unit: 1 dit length in milliseconds
    // Formula: 1200ms per minute / WPM = time for "PARIS " (50 dits)
    val ditMs: Long = (1200f / wpm).toLong()

    // Dah is 3 times a dit
    val dahMs: Long = ditMs * 3

    // Gap between dots and dashes within a character (like in K: -·-)
    val intraCharacterGapMs: Long = ditMs

    // Gap between characters (like between K and C)
    val interCharacterGapMs: Long = ditMs * 3

    // Gap between words
    val interWordGapMs: Long = ditMs * 7

    companion object {
        /**
         * Calculates the total duration of a morse pattern in milliseconds
         */
        fun calculateDuration(pattern: String, config: MorseTimingConfig): Long {
            var duration = 0L

            pattern.forEach { char ->
                duration += when (char) {
                    '.', '·', '•' -> config.ditMs
                    '-', '−', '–', '—' -> config.dahMs
                    ' ' -> config.interCharacterGapMs
                    else -> 0L
                }
                // Add intra-character gap after each element (except spaces)
                if (char != ' ') {
                    duration += config.intraCharacterGapMs
                }
            }

            // Add final inter-character gap
            duration += config.interCharacterGapMs
            return duration
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\data\MorseTimingConfig.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\data\SessionRepository.kt
--------------------------------------------------------------------------------

/*
 * ============================================================================
 * FILE: SessionRepository.kt
 * LOCATION: app/src/main/java/com/example/brutemorse/data/SessionRepository.kt
 * STATUS: ✅ FIXED - All timing type annotations added
 *
 * CHANGES MADE:
 * - Line ~437: Added explicit MorseTimingConfig type in createNestedIDStep()
 * - Line ~485: Added explicit MorseTimingConfig type in createSessionStepWithRepetition()
 * - Line ~526: Added explicit MorseTimingConfig type in createSessionStep()
 * ============================================================================
 */

package com.example.brutemorse.data

import com.example.brutemorse.model.ChimeElement
import com.example.brutemorse.model.MorseDefinitions
import com.example.brutemorse.model.MorseElement
import com.example.brutemorse.model.PhaseDescriptor
import com.example.brutemorse.model.ScenarioCategory
import com.example.brutemorse.model.ScenarioScript
import com.example.brutemorse.model.SessionStep
import com.example.brutemorse.model.SilenceElement
import com.example.brutemorse.model.SpeechElement
import com.example.brutemorse.model.UserSettings
import kotlinx.coroutines.flow.first
import kotlin.math.ceil

class SessionRepository(private val settingsRepository: SettingsRepository) {

    val scenarios: List<ScenarioScript> = ScenarioLibrary.defaultScenarios

    suspend fun latestSettings(): UserSettings = settingsRepository.settings.first()

    suspend fun saveSettings(settings: UserSettings) {
        settingsRepository.update(settings)
    }

    suspend fun generateSession(settings: UserSettings): List<SessionStep> {
        val session = mutableListOf<SessionStep>()
        if (settings.phaseSelection.contains(1)) {
            session += generatePhase1(settings, phaseIndex = 1)
        }
        if (settings.phaseSelection.contains(2)) {
            session += generatePhase2(settings, phaseIndex = 2)
        }
        if (settings.phaseSelection.contains(3)) {
            session += generatePhase3(settings, phaseIndex = 3)
        }
        if (settings.phaseSelection.contains(4)) {
            session += generatePhase4(settings, phaseIndex = 4)
        }
        return session
    }

    private fun generatePhase1(settings: UserSettings, phaseIndex: Int): List<SessionStep> {
        val sequence = mutableListOf<SessionStep>()
        val letters = MorseDefinitions.alphabet
        var subPhase = 1

        val forwardPasses = letters.indices.map { index ->
            letters.subList(0, index + 1)
        }
        forwardPasses.forEachIndexed { passIndex, pass ->
            sequence += createNestedIDStep(
                settings = settings,
                repetitionCount = settings.repetitionPhase1NestedID,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "NestedID Incremental", "Forward alphabet build"),
                passIndex = passIndex,
                passCount = forwardPasses.size + letters.size,
                uniqueTokens = pass
            )
        }

        val reversedLetters = letters.reversed()
        val decrementalPasses = reversedLetters.indices.map { index ->
            reversedLetters.subList(0, index + 1)
        }
        decrementalPasses.forEachIndexed { passIndex, pass ->
            sequence += createNestedIDStep(
                settings = settings,
                repetitionCount = settings.repetitionPhase1NestedID,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "NestedID Decremental", "Reverse alphabet build"),
                passIndex = forwardPasses.size + passIndex,
                passCount = forwardPasses.size + decrementalPasses.size,
                uniqueTokens = pass
            )
        }

        subPhase++
        val bctSequence = bctTraversal(center = letters.size / 2, size = letters.size, direction = 1, coprime = 5)
        bctSequence.forEachIndexed { index, letterIndex ->
            val repeatedLetter = List(settings.repetitionPhase1BCT) { letters[letterIndex] }
            sequence += createSessionStepWithRepetition(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "BCT", "Balanced coprime traversal"),
                passIndex = index,
                passCount = bctSequence.size,
                tokens = repeatedLetter
            )
        }

        subPhase++
        MorseDefinitions.digraphs.forEachIndexed { passIndex, digraph ->
            val builds = digraph.indices.map { idx -> digraph.substring(0, idx + 1) }
            builds.forEachIndexed { buildIndex, token ->
                sequence += createSessionStep(
                    settings = settings,
                    descriptor = PhaseDescriptor(phaseIndex, subPhase, "Progressive build", "Common digraph construction"),
                    passIndex = passIndex,
                    passCount = MorseDefinitions.digraphs.size,
                    tokens = listOf(token),
                    elementIndex = buildIndex
                )
            }
        }

        subPhase++
        val confusionSets = listOf(
            listOf("E", "I", "S", "H"),
            listOf("T", "M", "O"),
            listOf("B", "D", "G", "K"),
            listOf("U", "V", "W"),
            listOf("F", "L", "P"),
            listOf("N", "R", "X"),
            listOf("C", "Y", "Q", "Z"),
            listOf("A", "N", "R", "W")
        )
        confusionSets.forEachIndexed { passIndex, set ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "TongueTwister", "Confusable letters"),
                passIndex = passIndex,
                passCount = confusionSets.size,
                tokens = set
            )
        }

        return sequence
    }

    private fun generatePhase2(settings: UserSettings, phaseIndex: Int): List<SessionStep> {
        val sequence = mutableListOf<SessionStep>()
        var subPhase = 1

        val numbers = MorseDefinitions.numbers

        val forwardPasses = numbers.indices.map { index ->
            numbers.subList(0, index + 1)
        }
        forwardPasses.forEachIndexed { passIndex, pass ->
            sequence += createNestedIDStep(
                settings = settings,
                repetitionCount = settings.repetitionPhase2NestedID,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "NestedID Incremental", "Forward numbers build"),
                passIndex = passIndex,
                passCount = forwardPasses.size + numbers.size,
                uniqueTokens = pass
            )
        }

        val reversedNumbers = numbers.reversed()
        val decrementalPasses = reversedNumbers.indices.map { index ->
            reversedNumbers.subList(0, index + 1)
        }
        decrementalPasses.forEachIndexed { passIndex, pass ->
            sequence += createNestedIDStep(
                settings = settings,
                repetitionCount = settings.repetitionPhase2NestedID,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "NestedID Decremental", "Reverse numbers build"),
                passIndex = forwardPasses.size + passIndex,
                passCount = forwardPasses.size + decrementalPasses.size,
                uniqueTokens = pass
            )
        }

        subPhase++
        val combined = MorseDefinitions.alphabet + numbers
        val bctSequence = bctTraversal(center = combined.size / 2, size = combined.size, direction = -1, coprime = 7)
        bctSequence.forEachIndexed { index, tokenIndex ->
            val repeatedToken = List(settings.repetitionPhase2BCT) { combined[tokenIndex] }
            sequence += createSessionStepWithRepetition(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "BCT", "Mixed set traversal"),
                passIndex = index,
                passCount = bctSequence.size,
                tokens = repeatedToken
            )
        }

        subPhase++
        val confusionSets = listOf(
            listOf("5", "S", "H"),
            listOf("1", "T", "J"),
            listOf("0", "O", "M"),
            listOf("6", "B"),
            listOf("9", "N"),
            listOf("2", "I", "U"),
            listOf("3", "V", "S"),
            listOf("4", "V"),
            listOf("7", "G", "Z"),
            listOf("8", "D", "B")
        )
        confusionSets.forEachIndexed { passIndex, set ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "TongueTwister", "Number-letter confusion"),
                passIndex = passIndex,
                passCount = confusionSets.size,
                tokens = set
            )
        }

        subPhase++
        val sequences = listOf(
            listOf("5", "9", "9"),
            listOf("1", "4", ".", "0", "6", "0"),
            listOf("7", ".", "0", "3", "0"),
            listOf("2", "8", ".", "3", "0", "0"),
            listOf("1", "4", "5", ".", "5", "0")
        )
        sequences.forEachIndexed { passIndex, set ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "Progressive build", "Number sequences"),
                passIndex = passIndex,
                passCount = sequences.size,
                tokens = set
            )
        }

        return sequence
    }

    private fun generatePhase3(settings: UserSettings, phaseIndex: Int): List<SessionStep> {
        val sequence = mutableListOf<SessionStep>()
        var subPhase = 1

        MorseDefinitions.hamVocabulary.forEachIndexed { passIndex, token ->
            sequence += createNestedIDStep(
                settings = settings,
                repetitionCount = settings.repetitionPhase3Vocab,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "Vocabulary", "Ham terms"),
                passIndex = passIndex,
                passCount = MorseDefinitions.hamVocabulary.size,
                uniqueTokens = listOf(token)
            )
        }

        subPhase++
        val qcodes = listOf(
            listOf("CQ", "QRZ", "QTH"),
            listOf("RST", "599", "DE"),
            listOf("WX", "QSL", "QSB"),
            listOf("QRM", "QRP", "QSY")
        )
        qcodes.forEachIndexed { passIndex, set ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "TongueTwister", "Q-code drills"),
                passIndex = passIndex,
                passCount = qcodes.size,
                tokens = set
            )
        }

        subPhase++
        val reducedSupportTerms = MorseDefinitions.hamVocabulary.shuffled().take(12)
        reducedSupportTerms.forEachIndexed { passIndex, token ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "Reduced vocal", "Sparse TTS"),
                passIndex = passIndex,
                passCount = reducedSupportTerms.size,
                tokens = listOf(token),
                voiceMultiplier = if (passIndex % 2 == 0) 2 else 0
            )
        }

        subPhase++
        val mixedSets = listOf(
            listOf("CQ", "DE", "K"),
            listOf("SOS", "599", "RST"),
            listOf("73", "88", "SK"),
            listOf("CQ", "QRZ", "QTH"),
            listOf("DE", "K", "AR")
        )
        mixedSets.forEachIndexed { passIndex, set ->
            sequence += createSessionStep(
                settings = settings,
                descriptor = PhaseDescriptor(phaseIndex, subPhase, "Mixed confusion", "Morse + prosigns"),
                passIndex = passIndex,
                passCount = mixedSets.size,
                tokens = set
            )
        }

        return sequence
    }

    private fun generatePhase4(settings: UserSettings, phaseIndex: Int): List<SessionStep> {
        val sequence = mutableListOf<SessionStep>()
        var subPhase = 0
        var scriptCounter = 0

        sequence += createSessionStep(
            settings = settings,
            descriptor = PhaseDescriptor(phaseIndex, subPhase, "Vocabulary review", "Morse majority"),
            passIndex = 0,
            passCount = 1,
            tokens = MorseDefinitions.hamVocabulary,
            voiceMultiplier = 1
        )

        ScenarioLibrary.defaultScenarios.groupBy { it.category }.toSortedMap(compareBy { it.ordinal }).forEach { (category, scripts) ->
            scripts.forEachIndexed { index, script ->
                subPhase++
                val resolvedLines = script.lines.map { line ->
                    replaceScenarioTokens(line, settings, scriptCounter++)
                }
                val tokens = resolvedLines.flatMap { line ->
                    line.split(' ').filter { it.isNotBlank() }
                }
                sequence += createSessionStep(
                    settings = settings,
                    descriptor = PhaseDescriptor(
                        phaseIndex = phaseIndex,
                        subPhaseIndex = subPhase,
                        title = when (category) {
                            ScenarioCategory.NORMAL -> "Normal QSO"
                            ScenarioCategory.SKYWARN -> "SKYWARN"
                            ScenarioCategory.APOCALYPSE -> "Apocalypse"
                        },
                        description = script.title
                    ),
                    passIndex = index,
                    passCount = scripts.size,
                    tokens = tokens
                )
            }
        }

        return sequence
    }

    // ✅ FIX 1: Explicit type annotation added
    private fun createNestedIDStep(
        settings: UserSettings,
        repetitionCount: Int,
        descriptor: PhaseDescriptor,
        passIndex: Int,
        passCount: Int,
        uniqueTokens: List<String>,
        elementIndex: Int = 0
    ): SessionStep {
        val playback = mutableListOf<com.example.brutemorse.model.PlaybackElement>()

        // ✅ FIX: Explicit type annotation
        val timing: com.example.brutemorse.data.MorseTimingConfig = settings.timing

        uniqueTokens.forEach { token ->
            repeat(repetitionCount) { repIndex ->
                val morse = MorseDefinitions.morseMap[token] ?: token.toCharArray().joinToString(" ") { char ->
                    MorseDefinitions.morseMap[char.toString()].orEmpty()
                }
                val normalized = if (morse.isBlank()) "·" else morse
                val duration = MorseTimingConfig.calculateDuration(normalized, timing)

                playback += MorseElement(
                    symbol = normalized,
                    character = token,
                    wpm = settings.wpm,
                    toneFrequencyHz = settings.toneFrequencyHz,
                    durationMillis = duration
                )

                val hasVocal = repIndex < 3 || (repIndex >= 3 && (repIndex - 2) % 5 == 0)

                if (hasVocal) {
                    playback += SpeechElement(token, durationMillis = 750L)
                }

                playback += SilenceElement(durationMillis = timing.interCharacterGapMs)
            }
        }
        playback += ChimeElement()

        return SessionStep(
            descriptor = descriptor,
            passIndex = passIndex,
            passCount = passCount,
            elementIndex = elementIndex,
            elements = playback
        )
    }

    // ✅ FIX 2: Explicit type annotation added
    private fun createSessionStepWithRepetition(
        settings: UserSettings,
        descriptor: PhaseDescriptor,
        passIndex: Int,
        passCount: Int,
        tokens: List<String>,
        elementIndex: Int = 0
    ): SessionStep {
        val playback = mutableListOf<com.example.brutemorse.model.PlaybackElement>()

        // ✅ FIX: Explicit type annotation
        val timing: com.example.brutemorse.data.MorseTimingConfig = settings.timing

        tokens.forEachIndexed { index, token ->
            val morse = MorseDefinitions.morseMap[token] ?: token.toCharArray().joinToString(" ") { char ->
                MorseDefinitions.morseMap[char.toString()].orEmpty()
            }
            val normalized = if (morse.isBlank()) "·" else morse
            val duration = MorseTimingConfig.calculateDuration(normalized, timing)

            playback += MorseElement(
                symbol = normalized,
                character = token,
                wpm = settings.wpm,
                toneFrequencyHz = settings.toneFrequencyHz,
                durationMillis = duration
            )

            val hasVocal = index < 3 || (index >= 3 && (index - 2) % 5 == 0)

            if (hasVocal) {
                playback += SpeechElement(token, durationMillis = 750L)
            }

            playback += SilenceElement(durationMillis = timing.interCharacterGapMs)
        }
        playback += ChimeElement()

        return SessionStep(
            descriptor = descriptor,
            passIndex = passIndex,
            passCount = passCount,
            elementIndex = elementIndex,
            elements = playback
        )
    }

    // ✅ FIX 3: Explicit type annotation added
    private fun createSessionStep(
        settings: UserSettings,
        descriptor: PhaseDescriptor,
        passIndex: Int,
        passCount: Int,
        tokens: List<String>,
        voiceMultiplier: Int = 1,
        elementIndex: Int = 0
    ): SessionStep {
        val playback = mutableListOf<com.example.brutemorse.model.PlaybackElement>()

        // ✅ FIX: Explicit type annotation
        val timing: com.example.brutemorse.data.MorseTimingConfig = settings.timing

        tokens.forEachIndexed { index, token ->
            val morse = MorseDefinitions.morseMap[token] ?: token.toCharArray().joinToString(" ") { char ->
                MorseDefinitions.morseMap[char.toString()].orEmpty()
            }
            val normalized = if (morse.isBlank()) "·" else morse
            val duration = MorseTimingConfig.calculateDuration(normalized, timing)

            playback += MorseElement(
                symbol = normalized,
                character = token,
                wpm = settings.wpm,
                toneFrequencyHz = settings.toneFrequencyHz,
                durationMillis = duration
            )

            if (voiceMultiplier > 0 && index % voiceMultiplier == 0) {
                playback += SpeechElement(token, durationMillis = 750L)
            } else if (voiceMultiplier == 0) {
                // no speech element
            }
            playback += SilenceElement(durationMillis = timing.interCharacterGapMs)
        }
        playback += ChimeElement()

        return SessionStep(
            descriptor = descriptor,
            passIndex = passIndex,
            passCount = passCount,
            elementIndex = elementIndex,
            elements = playback
        )
    }

    private fun bctTraversal(center: Int, size: Int, direction: Int, coprime: Int): List<Int> {
        val sequence = mutableListOf<Int>()
        val randomOffset = kotlin.random.Random.nextInt(size)
        for (i in 0 until size) {
            val offset = ceil(i / 2.0).toInt()
            val sign = if ((i + 1) % 2 == 0) -1 else 1
            val position = (center + direction * coprime * sign * offset + randomOffset).mod(size)
            sequence += position
        }
        return sequence
    }

    private fun replaceScenarioTokens(template: String, settings: UserSettings, order: Int): String {
        val callSign = settings.callSign.ifBlank { "N0CALL" }
        val friendList = settings.friendCallSigns.ifEmpty { listOf("W1AW", "K7QRP", "N5XYZ") }
        val friendCall = friendList[order % friendList.size]
        val qth = qthPool[order % qthPool.size]
        val signal = signalPool[order % signalPool.size]
        val weather = weatherPool[order % weatherPool.size]
        val freq = frequencyPool[order % frequencyPool.size]
        val rig = rigPool[order % rigPool.size]
        val power = powerPool[order % powerPool.size]

        val replacements = mapOf(
            "{MY_CALL}" to callSign,
            "{FRIEND_CALL}" to friendCall,
            "{MY_QTH}" to qth,
            "{SIGNAL}" to signal,
            "{WX}" to weather,
            "{FREQ}" to freq,
            "{RIG}" to rig,
            "{PWR}" to power
        )
        var result = template
        replacements.forEach { (token, value) ->
            result = result.replace(token, value)
        }
        return result
    }

    companion object {
        private val qthPool = listOf("Austin TX", "Seattle WA", "Denver CO", "Boston MA", "Tucson AZ")
        private val signalPool = listOf("599", "579", "559", "449", "339")
        private val weatherPool = listOf("SUNNY", "CLOUDY", "RAIN", "SNOW", "WINDY")
        private val frequencyPool = listOf("14.060", "7.030", "21.060", "10.110", "18.085")
        private val rigPool = listOf("ICOM IC-7300", "YAESU FT-991", "KENWOOD TS-590", "ELECRAFT K3", "YAESU FT-818")
        private val powerPool = listOf("5W", "25W", "50W", "100W", "QRP")
    }
}

private object ScenarioLibrary {
    val defaultScenarios = listOf(
        ScenarioScript(
            id = "normal1",
            title = "CQ Call and Contest Exchange",
            category = ScenarioCategory.NORMAL,
            lines = listOf(
                "CQ CQ CQ DE {MY_CALL} {MY_CALL} K",
                "{MY_CALL} DE {FRIEND_CALL} UR {SIGNAL} QTH {MY_QTH} K",
                "{FRIEND_CALL} DE {MY_CALL} R R UR {SIGNAL} QTH TEXAS WX {WX} RIG {RIG} K",
                "{MY_CALL} DE {FRIEND_CALL} R R FB OM PWR {PWR} 73 SK"
            )
        ),
        ScenarioScript(
            id = "normal2",
            title = "Technical Rig Discussion",
            category = ScenarioCategory.NORMAL,
            lines = listOf(
                "CQ CQ DE {MY_CALL} K",
                "{MY_CALL} DE {FRIEND_CALL} RIG {RIG} ANT DIPOLE",
                "{FRIEND_CALL} DE {MY_CALL} FB HW CPY {PWR} W",
                "{MY_CALL} DE {FRIEND_CALL} R R 73 SK"
            )
        ),
        ScenarioScript(
            id = "skywarn1",
            title = "Tornado Spotted",
            category = ScenarioCategory.SKYWARN,
            lines = listOf(
                "NET CONTROL DE {MY_CALL} TORNADO SPOTTED 5 MILES WEST OF {MY_QTH} MOVING NORTHEAST K",
                "{MY_CALL} DE NET CONTROL ROGER RELAY TO NWS CONTINUE REPORTS K"
            )
        ),
        ScenarioScript(
            id = "apocalypse1",
            title = "Grid Down Supply Check",
            category = ScenarioCategory.APOCALYPSE,
            lines = listOf(
                "ANY STATION DE {MY_CALL} EMERGENCY TRAFFIC GRID DOWN NEED SUPPLY INFO K",
                "{MY_CALL} DE {FRIEND_CALL} COPY EMERGENCY SAFE ZONE AT {MY_QTH} FOOD WATER AVAILABLE K"
            )
        )
    )
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\data\SessionRepository.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\data\SettingsRepository.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.data

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences
import androidx.datastore.preferences.core.edit
import androidx.datastore.preferences.core.intPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey
import androidx.datastore.preferences.preferencesDataStore
import com.example.brutemorse.model.UserSettings
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore("brute_morse_settings")

private object PreferenceKeys {
    val CALLSIGN = stringPreferencesKey("callsign")
    val FRIEND_CALLSIGNS = stringPreferencesKey("friend_callsigns")
    val WPM = intPreferencesKey("wpm")
    val TONE = intPreferencesKey("tone")
    val PHASE_SELECTION = stringPreferencesKey("phases")

    // Per-phase repetition keys
    val REPETITION_PHASE1_NESTED = intPreferencesKey("rep_phase1_nested")
    val REPETITION_PHASE1_BCT = intPreferencesKey("rep_phase1_bct")
    val REPETITION_PHASE2_NESTED = intPreferencesKey("rep_phase2_nested")
    val REPETITION_PHASE2_BCT = intPreferencesKey("rep_phase2_bct")
    val REPETITION_PHASE3_VOCAB = intPreferencesKey("rep_phase3_vocab")

    val MIGRATION_DONE = stringPreferencesKey("migration_v2_done")
    val LAST_PLAYBACK_INDEX = intPreferencesKey("last_playback_index")
    val LAST_ACTIVE_INDEX = intPreferencesKey("last_active_index")
}

class SettingsRepository(private val context: Context) {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

    init {
        scope.launch {
            try {
                val prefs = context.dataStore.data.first()
                if (prefs[PreferenceKeys.MIGRATION_DONE] != "true") {
                    android.util.Log.d("SettingsRepository", "Migration v2 needed, running...")
                    migrateReversedData()
                } else {
                    android.util.Log.d("SettingsRepository", "Migration v2 already done")
                }
            } catch (e: Exception) {
                android.util.Log.e("SettingsRepository", "Migration error", e)
            }
        }
    }

    val settings: Flow<UserSettings> = context.dataStore.data.map { preferences ->
        preferences.toUserSettings()
    }

    private suspend fun migrateReversedData() {
        context.dataStore.edit { prefs ->
            android.util.Log.d("SettingsRepository", "Starting migration v2...")

            val callSign = prefs[PreferenceKeys.CALLSIGN]
            android.util.Log.d("SettingsRepository", "Current callsign: '$callSign'")

            if (!callSign.isNullOrEmpty()) {
                val fixed = callSign.reversed()
                prefs[PreferenceKeys.CALLSIGN] = fixed
                android.util.Log.d("SettingsRepository", "Reversed callsign: '$callSign' -> '$fixed'")
            }

            val friendString = prefs[PreferenceKeys.FRIEND_CALLSIGNS]
            android.util.Log.d("SettingsRepository", "Current friends: '$friendString'")

            if (!friendString.isNullOrEmpty()) {
                val friends = friendString.split(',').map { it.trim() }
                val fixedFriends = friends.map { friend ->
                    if (friend.isNotEmpty()) {
                        friend.reversed()
                    } else {
                        friend
                    }
                }
                prefs[PreferenceKeys.FRIEND_CALLSIGNS] = fixedFriends.joinToString(",")
                android.util.Log.d("SettingsRepository", "Reversed friends: '$friendString' -> '${fixedFriends.joinToString(",")}'")
            }

            prefs[PreferenceKeys.MIGRATION_DONE] = "true"
            android.util.Log.d("SettingsRepository", "Migration v2 complete!")
        }
    }

    suspend fun update(settings: UserSettings) {
        context.dataStore.edit { prefs ->
            prefs[PreferenceKeys.CALLSIGN] = settings.callSign
            prefs[PreferenceKeys.FRIEND_CALLSIGNS] = settings.friendCallSigns.joinToString(",")
            prefs[PreferenceKeys.WPM] = settings.wpm
            prefs[PreferenceKeys.TONE] = settings.toneFrequencyHz
            prefs[PreferenceKeys.PHASE_SELECTION] = settings.phaseSelection.sorted().joinToString(",")

            // Save all repetition counts
            prefs[PreferenceKeys.REPETITION_PHASE1_NESTED] = settings.repetitionPhase1NestedID
            prefs[PreferenceKeys.REPETITION_PHASE1_BCT] = settings.repetitionPhase1BCT
            prefs[PreferenceKeys.REPETITION_PHASE2_NESTED] = settings.repetitionPhase2NestedID
            prefs[PreferenceKeys.REPETITION_PHASE2_BCT] = settings.repetitionPhase2BCT
            prefs[PreferenceKeys.REPETITION_PHASE3_VOCAB] = settings.repetitionPhase3Vocab
        }
    }

    suspend fun saveLastPlaybackIndex(index: Int) {
        context.dataStore.edit { prefs ->
            prefs[PreferenceKeys.LAST_PLAYBACK_INDEX] = index
        }
    }

    suspend fun getLastPlaybackIndex(): Int {
        val prefs = context.dataStore.data.first()
        return prefs[PreferenceKeys.LAST_PLAYBACK_INDEX] ?: -1
    }

    suspend fun saveLastActiveIndex(index: Int) {
        context.dataStore.edit { prefs ->
            prefs[PreferenceKeys.LAST_ACTIVE_INDEX] = index
        }
    }

    suspend fun getLastActiveIndex(): Int {
        val prefs = context.dataStore.data.first()
        return prefs[PreferenceKeys.LAST_ACTIVE_INDEX] ?: -1
    }

    private fun Preferences.toUserSettings(): UserSettings {
        val friendString = this[PreferenceKeys.FRIEND_CALLSIGNS].orEmpty()
        val phaseString = this[PreferenceKeys.PHASE_SELECTION].orEmpty()
        return UserSettings(
            callSign = this[PreferenceKeys.CALLSIGN].orEmpty(),
            friendCallSigns = friendString.split(',').filter { it.isNotBlank() },
            wpm = this[PreferenceKeys.WPM] ?: UserSettings.DEFAULT_WPM,
            toneFrequencyHz = this[PreferenceKeys.TONE] ?: UserSettings.DEFAULT_TONE_HZ,
            phaseSelection = phaseString.split(',').mapNotNull { it.toIntOrNull() }.toSet()
                .ifEmpty { setOf(1, 2, 3, 4) },

            // Load all repetition counts with defaults
            repetitionPhase1NestedID = this[PreferenceKeys.REPETITION_PHASE1_NESTED]
                ?: UserSettings.DEFAULT_REPETITION_LETTERS,
            repetitionPhase1BCT = this[PreferenceKeys.REPETITION_PHASE1_BCT]
                ?: UserSettings.DEFAULT_REPETITION_BCT,
            repetitionPhase2NestedID = this[PreferenceKeys.REPETITION_PHASE2_NESTED]
                ?: UserSettings.DEFAULT_REPETITION_NUMBERS,
            repetitionPhase2BCT = this[PreferenceKeys.REPETITION_PHASE2_BCT]
                ?: UserSettings.DEFAULT_REPETITION_BCT_MIX,
            repetitionPhase3Vocab = this[PreferenceKeys.REPETITION_PHASE3_VOCAB]
                ?: UserSettings.DEFAULT_REPETITION_VOCAB
        )
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\data\SettingsRepository.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\MainActivity.kt
--------------------------------------------------------------------------------

package com.example.brutemorse

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.viewModels
import androidx.compose.runtime.CompositionLocalProvider
import androidx.compose.runtime.staticCompositionLocalOf
import com.example.brutemorse.ui.navigation.BruteMorseNavHost
import com.example.brutemorse.ui.theme.BruteMorseTheme
import com.example.brutemorse.viewmodel.PlaybackViewModel
import com.example.brutemorse.viewmodel.PlaybackViewModelFactory

val LocalPlaybackViewModel = staticCompositionLocalOf<PlaybackViewModel> {
    error("PlaybackViewModel not provided")
}

class MainActivity : ComponentActivity() {

    private val playbackViewModel: PlaybackViewModel by viewModels {
        val app = application as BruteMorseApp
        PlaybackViewModelFactory(app.sessionRepository, app.settingsRepository, applicationContext)

    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            BruteMorseTheme {
                CompositionLocalProvider(LocalPlaybackViewModel provides playbackViewModel) {
                    BruteMorseNavHost()
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\MainActivity.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\model\Models.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.model

import kotlinx.serialization.Serializable

enum class SegmentType {
    MORSE_TONE,
    TEXT_TO_SPEECH,
    CHIME,
    SILENCE
}

@Serializable
sealed interface PlaybackElement {
    val durationMillis: Long
}

@Serializable
data class MorseElement(
    val symbol: String,
    val character: String,
    val wpm: Int,
    val toneFrequencyHz: Int,
    override val durationMillis: Long
) : PlaybackElement

@Serializable
data class SpeechElement(
    val text: String,
    override val durationMillis: Long
) : PlaybackElement

@Serializable
data class SilenceElement(
    override val durationMillis: Long
) : PlaybackElement

@Serializable
data class ChimeElement(
    override val durationMillis: Long = 1200L
) : PlaybackElement

@Serializable
data class PhaseDescriptor(
    val phaseIndex: Int,
    val subPhaseIndex: Int,
    val title: String,
    val description: String
)

@Serializable
data class SessionStep(
    val descriptor: PhaseDescriptor,
    val passIndex: Int,
    val passCount: Int,
    val elementIndex: Int,
    val elements: List<PlaybackElement>
)

@Serializable
data class ScenarioScript(
    val id: String,
    val title: String,
    val category: ScenarioCategory,
    val lines: List<String>
)

enum class ScenarioCategory { NORMAL, SKYWARN, APOCALYPSE }

/**
 * User settings data class with repetition counts for active recall training.
 * Each phase can have different repetition settings based on learning theory.
 */
data class UserSettings(
    val callSign: String = "",
    val friendCallSigns: List<String> = emptyList(),
    val wpm: Int = DEFAULT_WPM,
    val toneFrequencyHz: Int = DEFAULT_TONE_HZ,
    val phaseSelection: Set<Int> = setOf(1, 2, 3, 4),

    // Phase 1: Alphabet Learning
    val repetitionPhase1NestedID: Int = DEFAULT_REPETITION_LETTERS,  // Phase 1.1: Individual letters (A, AB, ABC...)
    val repetitionPhase1BCT: Int = DEFAULT_REPETITION_BCT,           // Phase 1.2: BCT traversal

    // Phase 2: Numbers + Mixed
    val repetitionPhase2NestedID: Int = DEFAULT_REPETITION_NUMBERS,  // Phase 2.1: Numbers (0, 01, 012...)
    val repetitionPhase2BCT: Int = DEFAULT_REPETITION_BCT_MIX,       // Phase 2.2: Letters + Numbers mixed

    // Phase 3: Vocabulary
    val repetitionPhase3Vocab: Int = DEFAULT_REPETITION_VOCAB        // Phase 3.1: Words (CQ, QTH, RST...)
) {
    // Centralized timing configuration - computed from WPM
    val timing: com.example.brutemorse.data.MorseTimingConfig
        get() = com.example.brutemorse.data.MorseTimingConfig(wpm)

    companion object {
        // Default values
        const val DEFAULT_WPM = 25
        const val DEFAULT_TONE_HZ = 800

        // Active recall repetition defaults
        const val DEFAULT_REPETITION_LETTERS = 3    // Letters: 3 reps (easier, familiar)
        const val DEFAULT_REPETITION_BCT = 3        // BCT traversal: 3 reps
        const val DEFAULT_REPETITION_NUMBERS = 3    // Numbers: 3 reps
        const val DEFAULT_REPETITION_BCT_MIX = 3    // Mixed set: 3 reps
        const val DEFAULT_REPETITION_VOCAB = 3      // Vocabulary: 3 reps (whole words)
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\model\Models.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\model\MorseDefinitions.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.model

object MorseDefinitions {
    val alphabet = ('A'..'Z').map { it.toString() }
    val numbers = (0..9).map { it.toString() }

    val morseMap = mapOf(
        "A" to ".-",
        "B" to "-...",
        "C" to "-.-.",
        "D" to "-..",
        "E" to ".",
        "F" to "..-.",
        "G" to "--.",
        "H" to "....",
        "I" to "..",
        "J" to ".---",
        "K" to "-.-",
        "L" to ".-..",
        "M" to "--",
        "N" to "-.",
        "O" to "---",
        "P" to ".--.",
        "Q" to "--.-",
        "R" to ".-.",
        "S" to "...",
        "T" to "-",
        "U" to "..-",
        "V" to "...-",
        "W" to ".--",
        "X" to "-..-",
        "Y" to "-.--",
        "Z" to "--..",
        "0" to "-----",
        "1" to ".----",
        "2" to "..---",
        "3" to "...--",
        "4" to "....-",
        "5" to ".....",
        "6" to "-....",
        "7" to "--...",
        "8" to "---..",
        "9" to "----.",
        "." to ".-.-.-"
    )

    val digraphs = listOf("TH", "AN", "ER", "ON", "RE", "ST", "ND", "AT", "EN", "OR", "CQ", "DE")
    val hamVocabulary = listOf(
        "CQ", "DX", "QTH", "QSL", "RST", "73", "88", "SK", "NET", "QRZ", "QRM", "QRP",
        "ANT", "RIG", "WX", "PWR", "HF", "VHF", "UHF", "CW", "SSB"
    )
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\model\MorseDefinitions.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\navigation\BruteMorseNavHost.kt
--------------------------------------------------------------------------------

/*
 * ============================================================================
 * FILE: BruteMorseNavHost.kt
 * LOCATION: app/src/main/java/com/example/brutemorse/ui/navigation/BruteMorseNavHost.kt
 * STATUS: ✅ FIXED - All StateFlow collections use proper delegation
 *
 * CHANGES MADE:
 * - Added import: androidx.compose.runtime.getValue (Line ~8)
 * - Line ~62: Listen screen - extracted state with 'by' delegation
 * - Line ~89: Active screen - extracted state with 'by' delegation
 * - Line ~108: FreePractice screen - extracted settingsState with 'by' delegation
 * - Line ~122: TimingPractice screen - extracted settingsState with 'by' delegation
 * - Line ~134: Challenges screen - extracted settingsState with 'by' delegation
 * - Line ~150: Settings screen - extracted settingsState with 'by' delegation
 * - Line ~164: KeyerTest screen - extracted keyerState with 'by' delegation
 * - Line ~173: RepetitionSettings screen - extracted settingsState with 'by' delegation
 * ============================================================================
 */

package com.example.brutemorse.ui.navigation

import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue  // ✅ FIX: Added import for 'by' delegation
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import com.example.brutemorse.LocalPlaybackViewModel
import com.example.brutemorse.ui.screens.ActiveScreen
import com.example.brutemorse.ui.screens.ChallengesScreen
import com.example.brutemorse.ui.screens.FreePracticeScreen
import com.example.brutemorse.ui.screens.KeyerTestScreen
import com.example.brutemorse.ui.screens.ListenScreen
import com.example.brutemorse.ui.screens.MainMenuScreen
import com.example.brutemorse.ui.screens.RepetitionSettingsScreen
import com.example.brutemorse.ui.screens.ScenarioLibraryScreen
import com.example.brutemorse.ui.screens.SettingsScreen
import com.example.brutemorse.ui.screens.TimingPracticeScreen

sealed class Screen(val route: String) {
    data object MainMenu : Screen("main_menu")
    data object Listen : Screen("listen")
    data object Active : Screen("active")
    data object FreePractice : Screen("free_practice")
    data object TimingPractice : Screen("timing_practice")
    data object Challenges : Screen("challenges")
    data object Settings : Screen("settings")
    data object Scenarios : Screen("scenarios")
    data object KeyerTest : Screen("keyer_test")
    data object RepetitionSettings : Screen("repetition_settings")
}

@Composable
fun BruteMorseNavHost(
    navController: NavHostController = rememberNavController(),
    modifier: Modifier = Modifier
) {
    val playbackViewModel = LocalPlaybackViewModel.current

    NavHost(
        navController = navController,
        startDestination = Screen.MainMenu.route,
        modifier = modifier
    ) {
        composable(Screen.MainMenu.route) {
            MainMenuScreen(
                onNavigateListen = {
                    // Only generate new session if one doesn't exist
                    val currentState = playbackViewModel.uiState.value
                    if (currentState.totalSteps == 0) {
                        playbackViewModel.generateSession()
                    }
                    navController.navigate(Screen.Listen.route)
                },
                onNavigateActive = {
                    // Only generate new session if one doesn't exist
                    val currentActiveState = playbackViewModel.activeState.value
                    if (currentActiveState.currentTokens.isEmpty()) {
                        playbackViewModel.generateActiveSession()
                    }
                    navController.navigate(Screen.Active.route)
                },
                onNavigateFreePractice = {
                    navController.navigate(Screen.FreePractice.route)
                },
                onNavigateTimingPractice = {
                    navController.navigate(Screen.TimingPractice.route)
                },
                onNavigateChallenges = {
                    navController.navigate(Screen.Challenges.route)
                },
                onNavigateSettings = {
                    navController.navigate(Screen.Settings.route)
                },
                onNavigateScenarios = {
                    navController.navigate(Screen.Scenarios.route)
                }
            )
        }

        composable(Screen.Listen.route) {
            // ✅ FIX: Extract state using 'by' delegation instead of .value
            val state by playbackViewModel.uiState.collectAsState()

            ListenScreen(
                state = state,
                onPlayPause = playbackViewModel::togglePlayback,
                onSkipNext = playbackViewModel::skipNext,
                onSkipPrevious = playbackViewModel::skipPrevious,
                onSkipPhase = playbackViewModel::skipPhase,
                onRestartSubPhase = playbackViewModel::restartSubPhase,
                onSeekToTime = playbackViewModel::seekToTime,
                onRegenerateSession = playbackViewModel::generateSession,
                onOpenSettings = { navController.navigate(Screen.Settings.route) },
                onNavigateHome = {
                    navController.navigate(Screen.MainMenu.route) {
                        popUpTo(Screen.MainMenu.route) { inclusive = true }
                    }
                },
                onPauseOnExit = playbackViewModel::pausePlayback,
                onJumpToPhase = playbackViewModel::jumpToPhase,
                onJumpToSubPhase = playbackViewModel::jumpToSubPhase
            )
        }

        composable(Screen.Active.route) {
            // ✅ FIX: Extract state using 'by' delegation
            val state by playbackViewModel.activeState.collectAsState()

            ActiveScreen(
                state = state,
                onKeyDown = playbackViewModel::onActiveKeyDown,
                onKeyUp = playbackViewModel::onActiveKeyUp,
                onNextSet = playbackViewModel::onActiveNextSet,
                onBack = playbackViewModel::onActiveBackToResults,
                onRestartSubPhase = playbackViewModel::restartActiveSubPhase,
                onSeekToStep = playbackViewModel::seekToActiveStep,
                onOpenSettings = { navController.navigate(Screen.Settings.route) },
                onNavigateHome = {
                    navController.navigate(Screen.MainMenu.route) {
                        popUpTo(Screen.MainMenu.route) { inclusive = true }
                    }
                },
                onEnableAudioInput = playbackViewModel::enableAudioInput,
                onJumpToPhase = playbackViewModel::jumpToPhaseActive,
                onJumpToSubPhase = playbackViewModel::jumpToSubPhaseActive
            )
        }

        composable(Screen.FreePractice.route) {
            // ✅ FIX: Extract settingsState using 'by' delegation
            val settingsState by playbackViewModel.settingsState.collectAsState()

            FreePracticeScreen(
                onNavigateHome = {
                    playbackViewModel.stopMorsePlayback()
                    navController.navigate(Screen.MainMenu.route) {
                        popUpTo(Screen.MainMenu.route) { inclusive = true }
                    }
                },
                onKeyDown = playbackViewModel::onActiveKeyDown,
                onKeyUp = playbackViewModel::onActiveKeyUp,
                onPlayback = playbackViewModel::playMorsePattern,
                onStopPlayback = playbackViewModel::stopMorsePlayback,
                settingsState = settingsState
            )
        }

        composable(Screen.TimingPractice.route) {
            // ✅ FIX: Extract settingsState using 'by' delegation
            val settingsState by playbackViewModel.settingsState.collectAsState()

            TimingPracticeScreen(
                onNavigateHome = {
                    navController.navigate(Screen.MainMenu.route) {
                        popUpTo(Screen.MainMenu.route) { inclusive = true }
                    }
                },
                onKeyDown = playbackViewModel::onActiveKeyDown,
                onKeyUp = playbackViewModel::onActiveKeyUp,
                settingsState = settingsState
            )
        }

        composable(Screen.Challenges.route) {
            // ✅ FIX: Extract settingsState using 'by' delegation
            val settingsState by playbackViewModel.settingsState.collectAsState()

            ChallengesScreen(
                onNavigateHome = {
                    playbackViewModel.stopMorsePlayback()
                    navController.navigate(Screen.MainMenu.route) {
                        popUpTo(Screen.MainMenu.route) { inclusive = true }
                    }
                },
                onKeyDown = playbackViewModel::onActiveKeyDown,
                onKeyUp = playbackViewModel::onActiveKeyUp,
                onPlayback = playbackViewModel::playMorsePattern,
                onStopPlayback = playbackViewModel::stopMorsePlayback,
                settingsState = settingsState
            )
        }

        composable(Screen.Settings.route) {
            // ✅ FIX: Extract settingsState using 'by' delegation
            val settingsState by playbackViewModel.settingsState.collectAsState()

            SettingsScreen(
                settingsState = settingsState,
                onSettingsChange = playbackViewModel::updateSettings,
                onNavigateUp = { navController.popBackStack() },
                onOpenKeyerTest = { navController.navigate(Screen.KeyerTest.route) },
                onOpenRepetitionSettings = { navController.navigate(Screen.RepetitionSettings.route) }
            )
        }

        composable(Screen.Scenarios.route) {
            ScenarioLibraryScreen(
                scenarios = playbackViewModel.scenarios,
                onNavigateUp = { navController.popBackStack() }
            )
        }

        composable(Screen.KeyerTest.route) {
            // ✅ FIX: Extract keyerState using 'by' delegation
            val keyerState by playbackViewModel.keyerTestState.collectAsState()

            KeyerTestScreen(
                onNavigateBack = { navController.popBackStack() },
                onStartListening = playbackViewModel::startKeyerTest,
                onStopListening = playbackViewModel::stopKeyerTest,
                keyerState = keyerState
            )
        }

        composable(Screen.RepetitionSettings.route) {
            // ✅ FIX: Extract settingsState using 'by' delegation
            val settingsState by playbackViewModel.settingsState.collectAsState()

            RepetitionSettingsScreen(
                settingsState = settingsState,
                onSettingsChange = playbackViewModel::updateSettings,
                onNavigateUp = { navController.popBackStack() }
            )
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\navigation\BruteMorseNavHost.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\ActiveScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.example.brutemorse.viewmodel.ActiveUiState
import com.example.brutemorse.viewmodel.CharacterAttempt

@Composable
fun ActiveScreen(
    state: ActiveUiState,
    onKeyDown: () -> Unit,
    onKeyUp: () -> Unit,
    onNextSet: () -> Unit,
    onBack: () -> Unit,
    onRestartSubPhase: () -> Unit = {},
    onSeekToStep: (Int) -> Unit = {},
    onOpenSettings: () -> Unit,
    onNavigateHome: () -> Unit = {},
    onEnableAudioInput: () -> Unit = {},
    onJumpToPhase: (Int) -> Unit = {},
    onJumpToSubPhase: (Int, Int) -> Unit = { _, _ -> }
) {
    var isKeyPressed by remember { mutableStateOf(false) }
    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .let { base ->
                if (!state.isReviewMode) base.verticalScroll(scrollState) else base
            },
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateHome) {
                Icon(imageVector = Icons.Filled.Home, contentDescription = "Home")
            }
            Text("Active Practice", style = MaterialTheme.typography.titleLarge)
            IconButton(onClick = onOpenSettings) {
                Icon(imageVector = Icons.Filled.Menu, contentDescription = "Open settings")
            }
        }

        if (state.currentTokens.isNotEmpty()) {
            // Phase info card
            val descriptor = state.phaseDescriptor
            if (descriptor != null) {
                ElevatedCard(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.elevatedCardColors()
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalArrangement = Arrangement.spacedBy(4.dp)
                    ) {
                        Text(
                            text = "Phase ${descriptor.phaseIndex}.${descriptor.subPhaseIndex}",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )
                        Text(
                            text = descriptor.title,
                            style = MaterialTheme.typography.bodyMedium
                        )
                        Text(
                            text = "Pass ${state.passIndex + 1} / ${state.totalPasses}",
                            style = MaterialTheme.typography.labelMedium
                        )
                    }
                }
            }

            // Progress bar
            var isUserSeeking by remember { mutableStateOf(false) }
            var seekValue by remember { mutableFloatStateOf(0f) }

            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Progress: Step ${state.stepIndex + 1} / ${state.totalSteps}",
                    style = MaterialTheme.typography.bodyMedium
                )

                Slider(
                    value = if (isUserSeeking) {
                        seekValue
                    } else {
                        if (state.totalSteps == 0) 0f
                        else state.stepIndex / state.totalSteps.toFloat()
                    },
                    onValueChange = { value ->
                        isUserSeeking = true
                        seekValue = value
                    },
                    onValueChangeFinished = {
                        isUserSeeking = false
                        val targetStep = (seekValue * state.totalSteps).toInt().coerceIn(0, state.totalSteps - 1)
                        onSeekToStep(targetStep)
                    },
                    modifier = Modifier.fillMaxWidth()
                )
            }

            if (!state.isReviewMode) {
                // Prompt section
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        horizontalAlignment = Alignment.CenterHorizontally,
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Text(
                            text = "Send these characters:",
                            style = MaterialTheme.typography.bodyLarge
                        )
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(16.dp),
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            state.currentTokens.forEachIndexed { index, token ->
                                Box(
                                    modifier = Modifier.weight(1f),
                                    contentAlignment = Alignment.Center
                                ) {
                                    Text(
                                        text = token,
                                        style = MaterialTheme.typography.displayMedium,
                                        fontWeight = if (index == state.currentPosition) FontWeight.Bold else FontWeight.Normal,
                                        color = if (index < state.currentPosition) {
                                            MaterialTheme.colorScheme.tertiary
                                        } else if (index == state.currentPosition) {
                                            MaterialTheme.colorScheme.primary
                                        } else {
                                            MaterialTheme.colorScheme.onSurfaceVariant
                                        }
                                    )
                                }
                            }
                        }
                        Text(
                            text = "Position: ${state.currentPosition + 1} / ${state.currentTokens.size}",
                            style = MaterialTheme.typography.labelLarge
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Current input display
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                ) {
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(24.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = if (state.currentInput.isEmpty()) "..." else state.currentInput,
                            style = MaterialTheme.typography.displayLarge,
                            textAlign = TextAlign.Center
                        )
                    }
                }

                // Key button
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(120.dp)
                        .background(
                            if (isKeyPressed) MaterialTheme.colorScheme.primary
                            else MaterialTheme.colorScheme.primaryContainer,
                            shape = MaterialTheme.shapes.large
                        )
                        .pointerInput(Unit) {
                            detectTapGestures(
                                onPress = {
                                    isKeyPressed = true
                                    onKeyDown()
                                    tryAwaitRelease()
                                    isKeyPressed = false
                                    onKeyUp()
                                }
                            )
                        },
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = if (isKeyPressed) "SENDING..." else "TAP & HOLD TO SEND",
                        style = MaterialTheme.typography.titleLarge,
                        color = if (isKeyPressed)
                            MaterialTheme.colorScheme.onPrimary
                        else
                            MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }

                // Restart subphase button (not in review mode)
                Button(
                    onClick = onRestartSubPhase,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Restart Subphase")
                }
            } else {
                // Results section
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    // Score card
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Text(
                                text = "Score: ${state.score.first} / ${state.score.second}",
                                style = MaterialTheme.typography.titleLarge,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }

                    // Results list
                    LazyColumn(
                        modifier = Modifier.weight(1f),
                        verticalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        items(state.attempts) { attempt ->
                            Card(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardDefaults.cardColors(
                                    containerColor = if (attempt.isCorrect)
                                        MaterialTheme.colorScheme.primaryContainer
                                    else
                                        MaterialTheme.colorScheme.errorContainer
                                )
                            ) {
                                Column(
                                    modifier = Modifier
                                        .fillMaxWidth()
                                        .padding(12.dp),
                                    verticalArrangement = Arrangement.spacedBy(4.dp)
                                ) {
                                    Row(
                                        modifier = Modifier.fillMaxWidth(),
                                        horizontalArrangement = Arrangement.SpaceBetween,
                                        verticalAlignment = Alignment.CenterVertically
                                    ) {
                                        Text(
                                            text = attempt.expectedChar,
                                            style = MaterialTheme.typography.headlineMedium,
                                            fontWeight = FontWeight.Bold
                                        )
                                        Text(
                                            text = if (attempt.isCorrect) "✓" else "✗",
                                            style = MaterialTheme.typography.headlineMedium
                                        )
                                    }
                                    Text(
                                        text = "Expected: ${attempt.expectedPattern}",
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                    Text(
                                        text = "You sent: ${attempt.userPattern.ifEmpty { "(nothing)" }}",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = if (attempt.isCorrect)
                                            MaterialTheme.colorScheme.onPrimaryContainer
                                        else
                                            MaterialTheme.colorScheme.onErrorContainer
                                    )
                                }
                            }
                        }
                    }

                    // Navigation buttons
                    Column(
                        modifier = Modifier.fillMaxWidth(),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalArrangement = Arrangement.spacedBy(12.dp)
                        ) {
                            OutlinedButton(
                                onClick = onBack,
                                modifier = Modifier.weight(1f)
                            ) {
                                Icon(Icons.Filled.ArrowBack, contentDescription = null)
                                Text("Back")
                            }

                            Button(
                                onClick = onNextSet,
                                modifier = Modifier.weight(1f)
                            ) {
                                Text("Next Set")
                            }
                        }

                        Button(
                            onClick = onRestartSubPhase,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Text("Restart Subphase")
                        }
                    }
                }
            }

            // Divider before phase navigation
            HorizontalDivider(
                modifier = Modifier.padding(vertical = 8.dp),
                thickness = 2.dp,
                color = MaterialTheme.colorScheme.outlineVariant
            )

            // Phase navigation
            val phases = listOf(
                1 to "Alphabet Mastery",
                2 to "Expanded Set",
                3 to "Words & Abbreviations",
                4 to "Real World QSOs"
            )

            Column(
                modifier = Modifier.fillMaxWidth(),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                phases.forEach { (phase, label) ->
                    val isCurrentPhase = phase == (state.phaseDescriptor?.phaseIndex ?: 1)

                    Button(
                        onClick = { onJumpToPhase(phase) },
                        modifier = Modifier.fillMaxWidth(),
                        colors = if (isCurrentPhase) {
                            androidx.compose.material3.ButtonDefaults.buttonColors()
                        } else {
                            androidx.compose.material3.ButtonDefaults.outlinedButtonColors()
                        }
                    ) {
                        Text("Phase $phase: $label")
                    }

                    if (isCurrentPhase) {
                        val subPhases = when (phase) {
                            1 -> listOf(
                                1 to "NestedID Forward",
                                2 to "BCT Traversal",
                                3 to "Digraph Build",
                                4 to "Tongue Twisters"
                            )
                            2 -> listOf(
                                1 to "Nested Numbers",
                                2 to "Full BCT Mix",
                                3 to "Number/Letter Confusion",
                                4 to "Number Sequences"
                            )
                            3 -> listOf(
                                1 to "Ham Vocabulary",
                                2 to "Q-Code Drills",
                                3 to "Reduced Vocal",
                                4 to "Mixed Confusion"
                            )
                            4 -> listOf(
                                0 to "Vocab Review",
                                1 to "Normal QSOs",
                                5 to "SKYWARN",
                                9 to "Apocalypse"
                            )
                            else -> emptyList()
                        }

                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
                        ) {
                            Column(modifier = Modifier.padding(8.dp)) {
                                subPhases.forEach { (subPhaseNum, subPhaseLabel) ->
                                    val isCurrentSubPhase = subPhaseNum == (state.phaseDescriptor?.subPhaseIndex ?: 1)
                                    Text(
                                        text = "${phase}.${subPhaseNum}: $subPhaseLabel",
                                        style = if (isCurrentSubPhase) {
                                            MaterialTheme.typography.bodyMedium.copy(
                                                color = MaterialTheme.colorScheme.primary,
                                                fontWeight = FontWeight.Bold
                                            )
                                        } else {
                                            MaterialTheme.typography.bodySmall
                                        },
                                        modifier = Modifier
                                            .fillMaxWidth()
                                            .clickable { onJumpToSubPhase(phase, subPhaseNum) }
                                            .padding(vertical = 4.dp)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        } else {
            // Empty state
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(32.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    "Press Resume or start to begin active practice",
                    style = MaterialTheme.typography.bodyLarge,
                    textAlign = TextAlign.Center
                )
                Button(
                    onClick = onRestartSubPhase,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Resume Practice")
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\ActiveScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\ChallengesScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableLongStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.UserSettings
import com.example.brutemorse.model.MorseDefinitions
import kotlinx.coroutines.delay

@Composable
fun ChallengesScreen(
    onNavigateHome: () -> Unit,
    onKeyDown: () -> Unit,
    onKeyUp: () -> Unit,
    onPlayback: (String) -> Unit,
    onStopPlayback: () -> Unit,
    settingsState: UserSettings
) {
    var isKeyPressed by remember { mutableStateOf(false) }
    var userInput by remember { mutableStateOf("") }
    var currentLetter by remember { mutableStateOf("") }
    var decodedInput by remember { mutableStateOf("") }
    var lastTapTime by remember { mutableLongStateOf(0L) }
    var isComplete by remember { mutableStateOf(false) }
    val scrollState = rememberScrollState()

    // Sample challenges - you can expand this
    val challenges = listOf(
        "CQ CQ DE N0CALL K",
        "UR RST 599 K",
        "73 SK",
        "QTH TEXAS K"
    )
    var currentChallengeIndex by remember { mutableStateOf(0) }
    val currentChallenge = challenges[currentChallengeIndex]

    // Stop playback when leaving this screen
    DisposableEffect(Unit) {
        onDispose {
            onStopPlayback()
        }
    }

    // Helper to decode morse to character
    fun decodeMorse(pattern: String): String {
        val standardPattern = pattern.replace("•", ".").replace("—", "-")
        return MorseDefinitions.morseMap.entries
            .firstOrNull { it.value == standardPattern }?.key ?: "?"
    }

    // Helper function to convert text to morse pattern
    fun textToMorse(text: String): String {
        return text.map { char ->
            when {
                char == ' ' -> "   " // Word space
                char.isWhitespace() -> " "
                else -> MorseDefinitions.morseMap[char.toString()] ?: ""
            }
        }.joinToString(" ") // Letter space between characters
    }

    val ditUnit = (1200f / settingsState.wpm).toLong()
    val letterGap = ditUnit * 3
    val wordGap = ditUnit * 7

    // Check for gaps to add spaces
    LaunchedEffect(Unit) {
        while (true) {
            delay(100)
            val now = System.currentTimeMillis()
            val timeSinceLastTap = now - lastTapTime

            if (lastTapTime > 0 && currentLetter.isNotEmpty() && !isComplete) {
                when {
                    timeSinceLastTap > wordGap -> {
                        val decoded = decodeMorse(currentLetter)
                        userInput += currentLetter + "   "
                        decodedInput += decoded + "   "
                        currentLetter = ""
                        lastTapTime = 0
                    }
                    timeSinceLastTap > letterGap -> {
                        val decoded = decodeMorse(currentLetter)
                        userInput += currentLetter + " "
                        decodedInput += decoded + " "
                        currentLetter = ""
                        lastTapTime = 0
                    }
                }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateHome) {
                Icon(imageVector = Icons.Filled.Home, contentDescription = "Home")
            }
            Text("Challenges", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.weight(0.1f))
        }

        // Challenge card
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Type this:",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = currentChallenge,
                    style = MaterialTheme.typography.headlineMedium,
                    textAlign = TextAlign.Center
                )
                Text(
                    text = "Challenge ${currentChallengeIndex + 1} of ${challenges.size}",
                    style = MaterialTheme.typography.labelMedium
                )
            }
        }

        // User input display - shows decoded text above morse
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Your input:",
                    style = MaterialTheme.typography.labelLarge
                )
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 150.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    // Decoded text (letters/numbers)
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .heightIn(min = 50.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = if (decodedInput.isEmpty() && currentLetter.isEmpty())
                                ""
                            else {
                                val currentDecoded = if (currentLetter.isNotEmpty())
                                    decodeMorse(currentLetter)
                                else ""
                                decodedInput + currentDecoded
                            },
                            style = MaterialTheme.typography.headlineMedium,
                            textAlign = TextAlign.Center,
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Bold
                        )
                    }

                    // Morse code symbols
                    Box(
                        modifier = Modifier
                            .fillMaxWidth()
                            .heightIn(min = 70.dp),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = if (userInput.isEmpty() && currentLetter.isEmpty())
                                "Start typing..."
                            else
                                userInput + currentLetter,
                            style = MaterialTheme.typography.titleLarge,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }

        if (!isComplete) {
            // Key button
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp)
                    .background(
                        if (isKeyPressed) MaterialTheme.colorScheme.primary
                        else MaterialTheme.colorScheme.primaryContainer,
                        shape = MaterialTheme.shapes.large
                    )
                    .pointerInput(Unit) {
                        detectTapGestures(
                            onPress = {
                                isKeyPressed = true
                                onKeyDown()
                                val startTime = System.currentTimeMillis()
                                tryAwaitRelease()
                                val duration = System.currentTimeMillis() - startTime
                                isKeyPressed = false
                                onKeyUp()

                                val ditMax = ditUnit * 2.0
                                val symbol = if (duration < ditMax) "•" else "—"
                                currentLetter += symbol
                                lastTapTime = System.currentTimeMillis()
                            }
                        )
                    },
                contentAlignment = Alignment.Center
            ) {
                Text(
                    text = if (isKeyPressed) "SENDING..." else "TAP & HOLD",
                    style = MaterialTheme.typography.titleLarge,
                    color = if (isKeyPressed)
                        MaterialTheme.colorScheme.onPrimary
                    else
                        MaterialTheme.colorScheme.onPrimaryContainer
                )
            }

            // Control buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = {
                        isComplete = true
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Done - Check")
                }

                Button(
                    onClick = {
                        userInput = ""
                        currentLetter = ""
                        decodedInput = ""
                        lastTapTime = 0
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Clear")
                }
            }
        } else {
            // Results section
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = MaterialTheme.colorScheme.tertiaryContainer
                )
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        text = "Result",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )

                    Text(
                        text = "Expected: $currentChallenge",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Text(
                        text = "You typed: ${userInput.trim()}",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    val match = userInput.trim() == currentChallenge
                    Text(
                        text = if (match) "✓ Perfect!" else "✗ Not quite",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = if (match)
                            MaterialTheme.colorScheme.primary
                        else
                            MaterialTheme.colorScheme.error
                    )
                }
            }

            // Playback buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                OutlinedButton(
                    onClick = {
                        // Play user's attempt - convert display symbols to morse
                        val morsePattern = userInput
                            .replace("•", ".")
                            .replace("—", "-")
                        onPlayback(morsePattern)
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Play Mine")
                }

                OutlinedButton(
                    onClick = {
                        // Play correct version - convert text to morse
                        val morsePattern = textToMorse(currentChallenge)
                        onPlayback(morsePattern)
                    },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Play Correct")
                }
            }

            // Stop button
            OutlinedButton(
                onClick = onStopPlayback,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Stop Playback")
            }

            // Next challenge button
            Button(
                onClick = {
                    currentChallengeIndex = (currentChallengeIndex + 1) % challenges.size
                    userInput = ""
                    currentLetter = ""
                    decodedInput = ""
                    isComplete = false
                    lastTapTime = 0
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Next Challenge")
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\ChallengesScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\FreePracticeScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableLongStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.UserSettings
import com.example.brutemorse.model.MorseDefinitions
import kotlinx.coroutines.delay

@Composable
fun FreePracticeScreen(
    onNavigateHome: () -> Unit,
    onKeyDown: () -> Unit,
    onKeyUp: () -> Unit,
    onPlayback: (String) -> Unit,
    onStopPlayback: () -> Unit,
    settingsState: UserSettings
) {
    var isKeyPressed by remember { mutableStateOf(false) }
    var typedText by remember { mutableStateOf("") }
    var lastTapTime by remember { mutableLongStateOf(0L) }
    var currentLetter by remember { mutableStateOf("") }
    var decodedText by remember { mutableStateOf("") }
    val scrollState = rememberScrollState()

    val ditUnit = (1200f / settingsState.wpm).toLong()
    val letterGap = ditUnit * 3  // 3 units between letters
    val wordGap = ditUnit * 7    // 7 units between words

    // Helper to decode morse to character
    fun decodeMorse(pattern: String): String {
        val standardPattern = pattern.replace("•", ".").replace("—", "-")
        return MorseDefinitions.morseMap.entries
            .firstOrNull { it.value == standardPattern }?.key ?: "?"
    }

    // Stop playback when leaving this screen
    DisposableEffect(Unit) {
        onDispose {
            onStopPlayback()
        }
    }

    // Check for gaps to add spaces
    LaunchedEffect(Unit) {
        while (true) {
            delay(100)
            val now = System.currentTimeMillis()
            val timeSinceLastTap = now - lastTapTime

            if (lastTapTime > 0 && currentLetter.isNotEmpty()) {
                when {
                    timeSinceLastTap > wordGap -> {
                        // Word gap detected - decode and add
                        val decoded = decodeMorse(currentLetter)
                        typedText += currentLetter + "   "
                        decodedText += decoded + "   "
                        currentLetter = ""
                        lastTapTime = 0
                    }
                    timeSinceLastTap > letterGap -> {
                        // Letter gap detected - decode and add
                        val decoded = decodeMorse(currentLetter)
                        typedText += currentLetter + " "
                        decodedText += decoded + " "
                        currentLetter = ""
                        lastTapTime = 0
                    }
                }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateHome) {
                Icon(imageVector = Icons.Filled.Home, contentDescription = "Home")
            }
            Text("Free Practice", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.weight(0.1f))
        }

        // Info card
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    text = "Practice freely at your own pace",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "Pause 3 units for letter space, 7 units for word space",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Speed: ${settingsState.wpm} WPM",
                    style = MaterialTheme.typography.labelMedium
                )
            }
        }

        // Display area - shows decoded text above morse
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp)
                    .heightIn(min = 200.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // Decoded text (letters/numbers)
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 50.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = if (decodedText.isEmpty() && currentLetter.isEmpty())
                            ""
                        else {
                            val currentDecoded = if (currentLetter.isNotEmpty())
                                decodeMorse(currentLetter)
                            else ""
                            decodedText + currentDecoded
                        },
                        style = MaterialTheme.typography.headlineMedium,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.primary,
                        fontWeight = FontWeight.Bold
                    )
                }

                // Morse code symbols
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .heightIn(min = 100.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = if (typedText.isEmpty() && currentLetter.isEmpty())
                            "Start tapping..."
                        else
                            typedText + currentLetter,
                        style = MaterialTheme.typography.displayMedium,
                        textAlign = TextAlign.Center
                    )
                }
            }
        }

        // Key button
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(140.dp)
                .background(
                    if (isKeyPressed) MaterialTheme.colorScheme.primary
                    else MaterialTheme.colorScheme.primaryContainer,
                    shape = MaterialTheme.shapes.large
                )
                .pointerInput(Unit) {
                    detectTapGestures(
                        onPress = {
                            isKeyPressed = true
                            onKeyDown()
                            val startTime = System.currentTimeMillis()
                            tryAwaitRelease()
                            val duration = System.currentTimeMillis() - startTime
                            isKeyPressed = false
                            onKeyUp()

                            // Determine dit or dah based on duration
                            val ditMax = ditUnit * 2.0
                            val symbol = if (duration < ditMax) "•" else "—"
                            currentLetter += symbol
                            lastTapTime = System.currentTimeMillis()
                        }
                    )
                },
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = if (isKeyPressed) "SENDING..." else "TAP & HOLD TO SEND",
                style = MaterialTheme.typography.titleLarge,
                color = if (isKeyPressed)
                    MaterialTheme.colorScheme.onPrimary
                else
                    MaterialTheme.colorScheme.onPrimaryContainer
            )
        }

        // Control buttons
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            OutlinedButton(
                onClick = {
                    // Convert display symbols back to standard morse and play
                    val fullText = typedText + currentLetter
                    if (fullText.isNotEmpty()) {
                        val morsePattern = fullText
                            .replace("•", ".")
                            .replace("—", "-")
                        onPlayback(morsePattern)
                    }
                },
                modifier = Modifier.weight(1f),
                enabled = (typedText + currentLetter).isNotEmpty()
            ) {
                Text("Replay")
            }

            OutlinedButton(
                onClick = onStopPlayback,
                modifier = Modifier.weight(1f)
            ) {
                Text("Stop")
            }

            Button(
                onClick = {
                    typedText = ""
                    currentLetter = ""
                    decodedText = ""
                    lastTapTime = 0
                },
                modifier = Modifier.weight(1f)
            ) {
                Text("Clear")
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\FreePracticeScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\KeyerTestScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import android.Manifest
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.delay

data class KeyerTestState(
    val isListening: Boolean = false,
    val currentRMS: Float = 0f,
    val noiseFloor: Float = 100f,
    val threshold: Float = 300f,
    val isKeyDown: Boolean = false,
    val currentInput: String = "",
    val lastDetection: String = "",
    val detectionCount: Int = 0
)

@Composable
fun KeyerTestScreen(
    onNavigateBack: () -> Unit,
    onStartListening: (Float) -> Unit = {},
    onStopListening: () -> Unit = {},
    keyerState: KeyerTestState = KeyerTestState()
) {
    var permissionGranted by remember { mutableStateOf(false) }
    var showPermissionNeeded by remember { mutableStateOf(true) }
    var sensitivity by remember { mutableFloatStateOf(2.5f) }

    val permissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        permissionGranted = isGranted
        showPermissionNeeded = false
        if (isGranted) {
            onStartListening(sensitivity)
        }
    }

    DisposableEffect(Unit) {
        onDispose {
            onStopListening()
        }
    }

    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateBack) {
                Icon(imageVector = Icons.Filled.ArrowBack, contentDescription = "Back")
            }
            Text("Keyer Test", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.width(48.dp))
        }

        // Permission section
        if (showPermissionNeeded && !permissionGranted) {
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp)
                ) {
                    Text(
                        "Microphone Permission Required",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )
                    Text("This test requires microphone access to detect your straight key.")
                    Button(
                        onClick = {
                            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Grant Permission")
                    }
                }
            }
        }

        // Sensitivity control
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text("Sensitivity: ${String.format("%.1f", sensitivity)}")
                Slider(
                    value = sensitivity,
                    onValueChange = {
                        sensitivity = it
                        if (keyerState.isListening) {
                            onStopListening()
                            onStartListening(sensitivity)
                        }
                    },
                    valueRange = 1.5f..5.0f
                )
                Text(
                    "Higher = more sensitive (easier to trigger)",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }

        // Audio levels visualization
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    "Audio Levels",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                // RMS Level
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("Current RMS:")
                    Text(
                        String.format("%.1f", keyerState.currentRMS),
                        fontWeight = FontWeight.Bold
                    )
                }
                LinearProgressIndicator(
                    progress = { (keyerState.currentRMS / 2000f).coerceIn(0f, 1f) },
                    modifier = Modifier.fillMaxWidth(),
                )

                // Noise Floor
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("Noise Floor:")
                    Text(
                        String.format("%.1f", keyerState.noiseFloor),
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.tertiary
                    )
                }

                // Threshold
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    Text("Threshold:")
                    Text(
                        String.format("%.1f", keyerState.threshold),
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.secondary
                    )
                }

                // Key State
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(80.dp)
                        .background(
                            if (keyerState.isKeyDown) MaterialTheme.colorScheme.primary
                            else MaterialTheme.colorScheme.surface,
                            shape = MaterialTheme.shapes.medium
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        if (keyerState.isKeyDown) "KEY DOWN" else "KEY UP",
                        style = MaterialTheme.typography.headlineMedium,
                        fontWeight = FontWeight.Bold,
                        color = if (keyerState.isKeyDown)
                            MaterialTheme.colorScheme.onPrimary
                        else
                            MaterialTheme.colorScheme.onSurface
                    )
                }
            }
        }

        // Detection display
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.secondaryContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    "Detection Output",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                Text("Current Input:", style = MaterialTheme.typography.labelMedium)
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .height(60.dp)
                        .background(
                            MaterialTheme.colorScheme.surface,
                            shape = MaterialTheme.shapes.small
                        ),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        keyerState.currentInput.ifEmpty { "..." },
                        style = MaterialTheme.typography.displaySmall
                    )
                }

                if (keyerState.lastDetection.isNotEmpty()) {
                    Text("Last Detected:", style = MaterialTheme.typography.labelMedium)
                    Text(
                        keyerState.lastDetection,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Bold
                    )
                }

                Text(
                    "Total Detections: ${keyerState.detectionCount}",
                    style = MaterialTheme.typography.labelMedium
                )
            }
        }

        // Control buttons
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            if (!keyerState.isListening) {
                Button(
                    onClick = {
                        if (permissionGranted) {
                            onStartListening(sensitivity)
                        } else {
                            permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = permissionGranted || !showPermissionNeeded
                ) {
                    Text("Start Listening")
                }
            } else {
                OutlinedButton(
                    onClick = onStopListening,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Stop Listening")
                }
            }
        }

        // Help text
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    "Tips:",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
                Text("• Make sure your straight key is plugged into the microphone jack")
                Text("• Or use a USB-C audio adapter if needed")
                Text("• The RMS should jump when you press the key")
                Text("• If RMS stays near noise floor, increase sensitivity")
                Text("• Wait a few seconds for noise floor to stabilize")
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\KeyerTestScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\ListenScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.Home
import androidx.compose.material.icons.filled.KeyboardDoubleArrowRight
import androidx.compose.material.icons.filled.Menu
import androidx.compose.material.icons.filled.Pause
import androidx.compose.material.icons.filled.PlayArrow
import androidx.compose.material3.Button
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.Slider
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableFloatStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.MorseElement
import com.example.brutemorse.model.PlaybackElement
import com.example.brutemorse.model.SpeechElement
import com.example.brutemorse.viewmodel.PlaybackUiState

@Composable
private fun PhaseNavigationButtons(
    currentPhase: Int,
    currentSubPhase: Int,
    onPhaseSelect: (Int) -> Unit,
    onSubPhaseSelect: (Int, Int) -> Unit
) {
    val phases = listOf(
        1 to "Alphabet Mastery",
        2 to "Expanded Set",
        3 to "Words & Abbreviations",
        4 to "Real World QSOs"
    )

    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        phases.forEach { (phase, label) ->
            val isCurrentPhase = phase == currentPhase

            // Phase button
            Button(
                onClick = { onPhaseSelect(phase) },
                modifier = Modifier.fillMaxWidth(),
                colors = if (isCurrentPhase) {
                    androidx.compose.material3.ButtonDefaults.buttonColors()
                } else {
                    androidx.compose.material3.ButtonDefaults.outlinedButtonColors()
                }
            ) {
                Text("Phase $phase: $label")
            }

            // Auto-expand current phase to show subphases
            if (isCurrentPhase) {
                SubPhaseList(
                    phase = phase,
                    currentSubPhase = currentSubPhase,
                    onSubPhaseSelect = onSubPhaseSelect
                )
            }
        }
    }
}

@Composable
private fun SubPhaseList(
    phase: Int,
    currentSubPhase: Int,
    onSubPhaseSelect: (Int, Int) -> Unit
) {
    val subPhases = when (phase) {
        1 -> listOf(
            1 to "NestedID Forward",
            2 to "BCT Traversal",
            3 to "Digraph Build",
            4 to "Tongue Twisters"
        )
        2 -> listOf(
            1 to "Nested Numbers",
            2 to "Full BCT Mix",
            3 to "Number/Letter Confusion",
            4 to "Number Sequences"
        )
        3 -> listOf(
            1 to "Ham Vocabulary",
            2 to "Q-Code Drills",
            3 to "Reduced Vocal",
            4 to "Mixed Confusion"
        )
        4 -> listOf(
            0 to "Vocab Review",
            1 to "Normal QSOs",
            5 to "SKYWARN",
            9 to "Apocalypse"
        )
        else -> emptyList()
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
    ) {
        Column(modifier = Modifier.padding(8.dp)) {
            subPhases.forEach { (subPhaseNum, subPhaseLabel) ->
                val isCurrentSubPhase = subPhaseNum == currentSubPhase
                Text(
                    text = "${phase}.${subPhaseNum}: $subPhaseLabel",
                    style = if (isCurrentSubPhase) {
                        MaterialTheme.typography.bodyMedium.copy(
                            color = MaterialTheme.colorScheme.primary,
                            fontWeight = FontWeight.Bold
                        )
                    } else {
                        MaterialTheme.typography.bodySmall
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .clickable { onSubPhaseSelect(phase, subPhaseNum) }
                        .padding(vertical = 4.dp)
                )
            }
        }
    }
}

@Composable
fun ListenScreen(
    state: PlaybackUiState,
    onPlayPause: () -> Unit,
    onSkipNext: () -> Unit,
    onSkipPrevious: () -> Unit,
    onSkipPhase: () -> Unit,
    onRestartSubPhase: () -> Unit = {},
    onSeekToTime: (Long) -> Unit = {},
    onRegenerateSession: () -> Unit = {},
    onOpenSettings: () -> Unit,
    onNavigateHome: () -> Unit = {},
    onPauseOnExit: () -> Unit = {},
    onJumpToPhase: (Int) -> Unit = {},
    onJumpToSubPhase: (Int, Int) -> Unit = { _, _ -> }
) {
    val currentStep = state.currentStep
    val scrollState = rememberScrollState()

    // Pause playback when leaving this screen
    DisposableEffect(Unit) {
        onDispose {
            onPauseOnExit()
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateHome) {
                Icon(imageVector = Icons.Filled.Home, contentDescription = "Home")
            }
            Text("Listen", style = MaterialTheme.typography.titleLarge)
            IconButton(onClick = onOpenSettings) {
                Icon(imageVector = Icons.Filled.Menu, contentDescription = "Open settings")
            }
        }

        if (currentStep != null) {
            PhaseHeader(state)
            PlaybackVisualizer(currentStep.elements)
            PlaybackDetails(state, onSeekToTime)
        } else {
            EmptyState()
        }

        // Fixed spacer instead of weighted
        Spacer(modifier = Modifier.height(16.dp))

        PlaybackControls(
            isPlaying = state.isPlaying,
            onPlayPause = onPlayPause,
            onSkipNext = onSkipNext,
            onSkipPrevious = onSkipPrevious,
            onSkipPhase = onSkipPhase,
            onRestartSubPhase = onRestartSubPhase,
            onRegenerateSession = onRegenerateSession
        )

        if (currentStep != null) {
            // Divider before phase navigation
            HorizontalDivider(
                modifier = Modifier.padding(vertical = 8.dp),
                thickness = 2.dp,
                color = MaterialTheme.colorScheme.outlineVariant
            )

            PhaseNavigationButtons(
                currentPhase = state.currentStep?.descriptor?.phaseIndex ?: 1,
                currentSubPhase = state.currentStep?.descriptor?.subPhaseIndex ?: 1,
                onPhaseSelect = onJumpToPhase,
                onSubPhaseSelect = onJumpToSubPhase
            )
        }
    }
}

@Composable
private fun PhaseHeader(state: PlaybackUiState) {
    val descriptor = state.currentStep?.descriptor ?: return

    ElevatedCard(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.elevatedCardColors()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = "Phase ${descriptor.phaseIndex}.${descriptor.subPhaseIndex}",
                style = MaterialTheme.typography.titleLarge
            )
            Text(descriptor.title, style = MaterialTheme.typography.bodyLarge)
            Text(descriptor.description, style = MaterialTheme.typography.bodyMedium)
            Text(
                text = "Pass ${state.currentStep?.passIndex?.plus(1)} / ${state.currentStep?.passCount}",
                style = MaterialTheme.typography.labelLarge
            )
        }
    }
}

@Composable
private fun PlaybackVisualizer(elements: List<PlaybackElement>) {
    val morse = elements.filterIsInstance<MorseElement>().firstOrNull()
    val speech = elements.filterIsInstance<SpeechElement>().firstOrNull()

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // During morse: show ONLY morse pattern (with nice symbols)
            // During speech: show ONLY letter
            // Otherwise: blank
            if (morse != null) {
                // Convert old symbols to nice ones
                val displaySymbol = morse.symbol
                    .replace(".", "•")
                    .replace("-", "—")
                    .replace("·", "•")  // In case old symbol is there

                Text(
                    text = displaySymbol,
                    style = MaterialTheme.typography.displayLarge,
                    textAlign = TextAlign.Center
                )
            } else if (speech != null) {
                Text(
                    text = speech.text,
                    style = MaterialTheme.typography.displayLarge,
                    textAlign = TextAlign.Center
                )
            } else {
                // Completely blank during silence
                Text(
                    text = "",
                    style = MaterialTheme.typography.displayLarge,
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}

@Composable
private fun PlaybackDetails(state: PlaybackUiState, onSeekToTime: (Long) -> Unit) {
    var isUserSeeking by remember { mutableStateOf(false) }
    var seekValue by remember { mutableFloatStateOf(0f) }

    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            text = "Elapsed ${formatDuration(state.elapsedMillis)} / ${formatDuration(state.totalMillis)}",
            style = MaterialTheme.typography.bodyLarge
        )

        // Interactive slider for seeking
        Slider(
            value = if (isUserSeeking) {
                seekValue
            } else {
                if (state.totalMillis == 0L) 0f
                else state.elapsedMillis / state.totalMillis.toFloat()
            },
            onValueChange = { value ->
                isUserSeeking = true
                seekValue = value
            },
            onValueChangeFinished = {
                isUserSeeking = false
                val targetMillis = (seekValue * state.totalMillis).toLong()
                onSeekToTime(targetMillis)
            },
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
private fun PlaybackControls(
    isPlaying: Boolean,
    onPlayPause: () -> Unit,
    onSkipNext: () -> Unit,
    onSkipPrevious: () -> Unit,
    onSkipPhase: () -> Unit,
    onRestartSubPhase: () -> Unit,
    onRegenerateSession: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxWidth(),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // Main playback controls
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                horizontalArrangement = Arrangement.SpaceEvenly,
                verticalAlignment = Alignment.CenterVertically
            ) {
                IconButton(onClick = onSkipPrevious) {
                    Icon(
                        imageVector = Icons.Filled.ArrowBack,
                        contentDescription = "Previous"
                    )
                }
                IconButton(onClick = onPlayPause) {
                    Icon(
                        imageVector = if (isPlaying) Icons.Filled.Pause else Icons.Filled.PlayArrow,
                        contentDescription = if (isPlaying) "Pause" else "Play"
                    )
                }
                IconButton(onClick = onSkipNext) {
                    Icon(
                        imageVector = Icons.Filled.ArrowForward,
                        contentDescription = "Next"
                    )
                }
                IconButton(onClick = onSkipPhase) {
                    Icon(
                        imageVector = Icons.Filled.KeyboardDoubleArrowRight,
                        contentDescription = "Next phase"
                    )
                }
            }
        }

        // Button row
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            // Resume button - only show when paused
            if (!isPlaying) {
                Button(
                    onClick = onPlayPause,
                    modifier = Modifier.weight(1f)
                ) {
                    Text("Resume")
                }
            }

            // Restart subphase button
            Button(
                onClick = onRestartSubPhase,
                modifier = Modifier.weight(1f)
            ) {
                Text("Restart Subphase")
            }
        }

        // Regenerate session button
        OutlinedButton(
            onClick = onRegenerateSession,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Regenerate Session (Apply WPM Changes)")
        }
    }
}

@Composable
private fun EmptyState() {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Text(
            "Press start to generate a marathon session",
            style = MaterialTheme.typography.bodyLarge
        )
    }
}

private fun formatDuration(millis: Long): String {
    val totalSeconds = millis / 1000
    val hours = totalSeconds / 3600
    val minutes = (totalSeconds % 3600) / 60
    val seconds = totalSeconds % 60
    return "%d:%02d:%02d".format(hours, minutes, seconds)
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\ListenScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\MainMenuScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.LibraryBooks
import androidx.compose.material.icons.filled.Settings
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp

@Composable
fun MainMenuScreen(
    onNavigateListen: () -> Unit,
    onNavigateActive: () -> Unit,
    onNavigateFreePractice: () -> Unit,
    onNavigateTimingPractice: () -> Unit,
    onNavigateChallenges: () -> Unit,
    onNavigateSettings: () -> Unit,
    onNavigateScenarios: () -> Unit
) {
    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(32.dp))

        Text(
            text = "Brute Morse",
            style = MaterialTheme.typography.displayMedium,
            fontWeight = FontWeight.Bold
        )

        Text(
            text = "Code Trainer",
            style = MaterialTheme.typography.titleLarge
        )

        Spacer(modifier = Modifier.height(24.dp))

        // Training Modes Section
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Text(
                    text = "5 Training Modes",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                // Listen Mode
                Button(
                    onClick = onNavigateListen,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("LISTEN", style = MaterialTheme.typography.titleMedium)
                        Text("Passive Learning", style = MaterialTheme.typography.bodySmall)
                    }
                }

                // Active Mode
                Button(
                    onClick = onNavigateActive,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("ACTIVE", style = MaterialTheme.typography.titleMedium)
                        Text("Guided Practice", style = MaterialTheme.typography.bodySmall)
                    }
                }

                // Free Practice
                Button(
                    onClick = onNavigateFreePractice,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("FREE PRACTICE", style = MaterialTheme.typography.titleMedium)
                        Text("Type Anything", style = MaterialTheme.typography.bodySmall)
                    }
                }

                // Timing Practice
                Button(
                    onClick = onNavigateTimingPractice,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("TIMING DRILL", style = MaterialTheme.typography.titleMedium)
                        Text("Perfect Your • and —", style = MaterialTheme.typography.bodySmall)
                    }
                }

                // Challenges
                Button(
                    onClick = onNavigateChallenges,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text("CHALLENGES", style = MaterialTheme.typography.titleMedium)
                        Text("Type Scenarios", style = MaterialTheme.typography.bodySmall)
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Utilities Section
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            FilledTonalButton(
                onClick = onNavigateSettings,
                modifier = Modifier.weight(1f)
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Icon(Icons.Filled.Settings, contentDescription = null)
                    Spacer(modifier = Modifier.height(4.dp))
                    Text("Settings")
                }
            }

            FilledTonalButton(
                onClick = onNavigateScenarios,
                modifier = Modifier.weight(1f)
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Icon(Icons.Filled.LibraryBooks, contentDescription = null)
                    Spacer(modifier = Modifier.height(4.dp))
                    Text("Scenarios")
                }
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\MainMenuScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\RepetitionSettingsScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.UserSettings

@Composable
fun RepetitionSettingsScreen(
    settingsState: UserSettings,
    onSettingsChange: ((UserSettings) -> UserSettings) -> Unit,
    onNavigateUp: () -> Unit
) {
    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header with back button
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateUp) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                    contentDescription = "Back"
                )
            }
            Text(
                "Repetition Settings",
                style = MaterialTheme.typography.titleLarge
            )
            // Spacer for symmetry
            IconButton(onClick = {}) {
                // Empty to maintain layout
            }
        }

        Text(
            "Configure how many times each element repeats during active recall training",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        HorizontalDivider()

        // Phase 1.1 NestedID
        RepetitionSlider(
            title = "Phase 1.1: Alphabet (NestedID)",
            description = "A, B, C... individual letters",
            currentValue = settingsState.repetitionPhase1NestedID,
            range = 3f..15f,
            onValueChange = { value ->
                onSettingsChange { it.copy(repetitionPhase1NestedID = value.toInt()) }
            }
        )

        // Phase 1.2 BCT
        RepetitionSlider(
            title = "Phase 1.2: Alphabet (BCT)",
            description = "Balanced coprime traversal",
            currentValue = settingsState.repetitionPhase1BCT,
            range = 3f..15f,
            onValueChange = { value ->
                onSettingsChange { it.copy(repetitionPhase1BCT = value.toInt()) }
            }
        )

        HorizontalDivider()

        // Phase 2.1 Numbers NestedID
        RepetitionSlider(
            title = "Phase 2.1: Numbers (NestedID)",
            description = "0, 1, 2... individual numbers",
            currentValue = settingsState.repetitionPhase2NestedID,
            range = 3f..15f,
            onValueChange = { value ->
                onSettingsChange { it.copy(repetitionPhase2NestedID = value.toInt()) }
            }
        )

        // Phase 2.2 Mixed BCT
        RepetitionSlider(
            title = "Phase 2.2: Mixed Set (BCT)",
            description = "Letters + Numbers combined",
            currentValue = settingsState.repetitionPhase2BCT,
            range = 3f..15f,
            onValueChange = { value ->
                onSettingsChange { it.copy(repetitionPhase2BCT = value.toInt()) }
            }
        )

        HorizontalDivider()

        // Phase 3.1 Vocabulary
        RepetitionSlider(
            title = "Phase 3.1: Vocabulary",
            description = "CQ, QTH, RST... whole words",
            currentValue = settingsState.repetitionPhase3Vocab,
            range = 3f..7f,  // Capped at 7 to prevent super long sessions
            onValueChange = { value ->
                onSettingsChange { it.copy(repetitionPhase3Vocab = value.toInt()) }
            }
        )

        HorizontalDivider()

        // Info card
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer
            )
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    "Pattern Explanation",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    "• First 3 reps: Morse + Vocal (M-V)",
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    "• Reps 4+: Morse only (M)",
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    "• Every 5th after position 3: Morse + Vocal (M-V)",
                    style = MaterialTheme.typography.bodySmall
                )
                Text(
                    "Example at 10 reps: M-V, M-V, M-V, M, M, M, M, M-V, M, M",
                    style = MaterialTheme.typography.bodySmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }

        // Reset button
        OutlinedButton(
            onClick = {
                onSettingsChange {
                    it.copy(
                        repetitionPhase1NestedID = UserSettings.DEFAULT_REPETITION_LETTERS,
                        repetitionPhase1BCT = UserSettings.DEFAULT_REPETITION_BCT,
                        repetitionPhase2NestedID = UserSettings.DEFAULT_REPETITION_NUMBERS,
                        repetitionPhase2BCT = UserSettings.DEFAULT_REPETITION_BCT_MIX,
                        repetitionPhase3Vocab = UserSettings.DEFAULT_REPETITION_VOCAB
                    )
                }
            },
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Reset All to Defaults (3)")
        }

        // Back button
        Button(
            onClick = onNavigateUp,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Back to Settings")
        }
    }
}

@Composable
private fun RepetitionSlider(
    title: String,
    description: String,
    currentValue: Int,
    range: ClosedFloatingPointRange<Float>,
    onValueChange: (Float) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surfaceVariant
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(modifier = Modifier.weight(1f)) {
                    Text(
                        text = title,
                        style = MaterialTheme.typography.titleSmall,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
                Text(
                    text = currentValue.toString(),
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            Slider(
                value = currentValue.toFloat(),
                onValueChange = onValueChange,
                valueRange = range,
                steps = (range.endInclusive - range.start).toInt() - 1
            )

            // Preview pattern
            val previewPattern = buildString {
                repeat(currentValue) { index ->
                    val hasVocal = index < 3 || (index >= 3 && (index - 2) % 5 == 0)
                    append(if (hasVocal) "M-V " else "M ")
                }
            }.trim()

            Text(
                text = "Pattern: $previewPattern",
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = Modifier.padding(top = 4.dp)
            )
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\RepetitionSettingsScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\ScenarioLibraryScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.ScenarioCategory
import com.example.brutemorse.model.ScenarioScript

@Composable
fun ScenarioLibraryScreen(
    scenarios: List<ScenarioScript>,
    onNavigateUp: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Text("Scenario Library", style = MaterialTheme.typography.titleLarge)
        LazyColumn(
            modifier = Modifier.weight(1f),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            items(scenarios) { scenario ->
                ScenarioCard(scenario)
            }
        }
        Button(onClick = onNavigateUp, modifier = Modifier.fillMaxWidth()) {
            Text("Back")
        }
    }
}

@Composable
private fun ScenarioCard(scenario: ScenarioScript) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = scenario.title,
                style = MaterialTheme.typography.titleLarge
            )
            Text(
                text = when (scenario.category) {
                    ScenarioCategory.NORMAL -> "Normal Rag-Chew"
                    ScenarioCategory.SKYWARN -> "SKYWARN"
                    ScenarioCategory.APOCALYPSE -> "Apocalypse"
                },
                style = MaterialTheme.typography.labelLarge
            )
            scenario.lines.forEach { line ->
                Text(text = line, style = MaterialTheme.typography.bodyMedium)
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\ScenarioLibraryScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\SettingsScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardCapitalization
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.UserSettings

@Composable
fun SettingsScreen(
    settingsState: UserSettings,
    onSettingsChange: ((UserSettings) -> UserSettings) -> Unit,
    onNavigateUp: () -> Unit,
    onOpenKeyerTest: () -> Unit = {},
    onOpenRepetitionSettings: () -> Unit = {}
) {
    var callSign by remember(settingsState.callSign) { mutableStateOf(settingsState.callSign) }
    var friends by remember(settingsState.friendCallSigns) {
        mutableStateOf(settingsState.friendCallSigns.joinToString(", "))
    }

    val scrollState = rememberScrollState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header with back button
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateUp) {
                Icon(
                    imageVector = Icons.AutoMirrored.Filled.ArrowBack,
                    contentDescription = "Back"
                )
            }
            Text("Settings", style = MaterialTheme.typography.titleLarge)
            // Empty spacer for symmetry
            IconButton(onClick = {}) {}
        }

        // Personal Info Section
        Text("Personal Information", style = MaterialTheme.typography.titleMedium)

        OutlinedTextField(
            value = callSign,
            onValueChange = { newValue ->
                callSign = newValue
                val uppercased = newValue.uppercase()
                onSettingsChange { settings -> settings.copy(callSign = uppercased) }
            },
            label = { Text("Your call sign") },
            modifier = Modifier.fillMaxWidth(),
            keyboardOptions = KeyboardOptions(
                capitalization = KeyboardCapitalization.Characters,
                keyboardType = KeyboardType.Ascii
            ),
            singleLine = true,
            colors = androidx.compose.material3.TextFieldDefaults.colors(
                focusedTextColor = MaterialTheme.colorScheme.onSurface,
                unfocusedTextColor = MaterialTheme.colorScheme.onSurface
            )
        )

        OutlinedTextField(
            value = friends,
            onValueChange = { newValue ->
                friends = newValue
                val entries = newValue.split(',')
                    .map { value -> value.trim().uppercase() }
                    .filter { value -> value.isNotEmpty() }
                onSettingsChange { settings -> settings.copy(friendCallSigns = entries.take(10)) }
            },
            label = { Text("Friend call signs (comma separated)") },
            modifier = Modifier.fillMaxWidth(),
            keyboardOptions = KeyboardOptions(
                capitalization = KeyboardCapitalization.Characters,
                keyboardType = KeyboardType.Ascii
            ),
            colors = androidx.compose.material3.TextFieldDefaults.colors(
                focusedTextColor = MaterialTheme.colorScheme.onSurface,
                unfocusedTextColor = MaterialTheme.colorScheme.onSurface
            )
        )

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        // Training Phases Section
        Text("Training Phases", style = MaterialTheme.typography.titleMedium)
        Text(
            "Select which phases to include in Listen and Active modes",
            style = MaterialTheme.typography.bodySmall
        )

        PhaseSelection(
            selected = settingsState.phaseSelection,
            onSelectionChange = { phases ->
                onSettingsChange { settings -> settings.copy(phaseSelection = phases) }
            }
        )

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        // Audio Settings Section
        Text("Audio Settings", style = MaterialTheme.typography.titleMedium)

        Text("Words per minute: ${settingsState.wpm}")
        Slider(
            value = settingsState.wpm.toFloat(),
            onValueChange = { value -> onSettingsChange { settings -> settings.copy(wpm = value.toInt()) } },
            valueRange = 15f..40f
        )

        Text("Tone frequency: ${settingsState.toneFrequencyHz} Hz")
        Slider(
            value = settingsState.toneFrequencyHz.toFloat(),
            onValueChange = { value -> onSettingsChange { settings -> settings.copy(toneFrequencyHz = value.toInt()) } },
            valueRange = 400f..1200f
        )

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        // Repetition Settings Button
        Text("Active Recall Settings", style = MaterialTheme.typography.titleMedium)

        Button(
            onClick = onOpenRepetitionSettings,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Configure Repetition Settings →")
        }

        Text(
            "Customize how many times each element repeats per phase",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        // Hardware Testing Section
        Text("Hardware Testing", style = MaterialTheme.typography.titleMedium)

        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.errorContainer)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Text(
                    "⚠️ Important: Straight Key Compatibility",
                    style = MaterialTheme.typography.titleSmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
                Text(
                    "This app works ONLY with straight keys that produce an audio tone when closed (like the VK-5).",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
                Text(
                    "Keys that simply close a circuit (like traditional telegraph keys) will NOT work. The app detects audio input through the microphone jack.",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        }

        Button(
            onClick = onOpenKeyerTest,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Test Physical Straight Key / Audio Input")
        }

        HorizontalDivider(modifier = Modifier.padding(vertical = 8.dp))

        Button(onClick = onNavigateUp, modifier = Modifier.fillMaxWidth()) {
            Text("Back to Menu")
        }
    }
}

@Composable
private fun PhaseSelection(
    selected: Set<Int>,
    onSelectionChange: (Set<Int>) -> Unit
) {
    val phases = listOf(
        1 to "Phase 1: Alphabet Mastery",
        2 to "Phase 2: Expanded Set",
        3 to "Phase 3: Words & Abbreviations",
        4 to "Phase 4: Real World QSOs"
    )

    Column(verticalArrangement = Arrangement.spacedBy(4.dp)) {
        phases.forEach { (index, title) ->
            val isChecked = selected.contains(index)
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(title, style = MaterialTheme.typography.bodyLarge, modifier = Modifier.weight(1f))
                Checkbox(
                    checked = isChecked,
                    onCheckedChange = { checked ->
                        val newSelection = selected.toMutableSet()
                        if (checked) newSelection += index else newSelection -= index
                        onSelectionChange(newSelection)
                    }
                )
            }
        }
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\SettingsScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\screens\TimingPracticeScreen.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.screens

import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.LinearEasing
import androidx.compose.animation.core.tween
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectTapGestures
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Home
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableLongStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.brutemorse.model.UserSettings
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

enum class PracticeMode {
    DIT, DAH, BOTH
}

@Composable
fun TimingPracticeScreen(
    onNavigateHome: () -> Unit,
    onKeyDown: () -> Unit,
    onKeyUp: () -> Unit,
    settingsState: UserSettings
) {
    var score by remember { mutableIntStateOf(0) }
    var attempts by remember { mutableIntStateOf(0) }
    var isPressed by remember { mutableStateOf(false) }
    var feedback by remember { mutableStateOf<FeedbackState>(FeedbackState.None) }
    var currentMode by remember { mutableStateOf(PracticeMode.BOTH) }
    var currentTarget by remember { mutableStateOf<TargetType>(TargetType.DIT) }
    var pressStartTime by remember { mutableLongStateOf(0L) }

    val sliderPosition = remember { Animatable(1f) } // Start from right (1.0)
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    // Use centralized timing configuration
    val timing = settingsState.timing

    // Total time for slider to cross (make it visible)
    val totalSliderTimeMs = 250L

    // Calculate zones as percentages of the slider
    // Allow 20% tolerance on timing
    val ditGreenStart = (timing.ditMs.toFloat() / totalSliderTimeMs) * 0.8f
    val ditGreenEnd = (timing.ditMs.toFloat() / totalSliderTimeMs) * 1.2f
    val ditRedEnd = ditGreenEnd + 0.15f // Red zone after green

    val dahGreenStart = (timing.dahMs.toFloat() / totalSliderTimeMs) * 0.8f
    val dahGreenEnd = (timing.dahMs.toFloat() / totalSliderTimeMs) * 1.2f
    val dahRedEnd = dahGreenEnd + 0.15f

    // Select target based on mode
    LaunchedEffect(currentMode) {
        // Set the FIRST target when mode changes
        currentTarget = when (currentMode) {
            PracticeMode.DIT -> TargetType.DIT
            PracticeMode.DAH -> TargetType.DAH
            PracticeMode.BOTH -> TargetType.DIT // Start with DIT
        }
    }

    LaunchedEffect(feedback) {
        if (feedback != FeedbackState.None) {
            delay(800)
            feedback = FeedbackState.None

            // After feedback clears, set up NEXT target
            currentTarget = when (currentMode) {
                PracticeMode.DIT -> TargetType.DIT
                PracticeMode.DAH -> TargetType.DAH
                PracticeMode.BOTH -> {
                    // Alternate: if we just did DIT, next is DAH, and vice versa
                    if (currentTarget == TargetType.DIT) TargetType.DAH else TargetType.DIT
                }
            }
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(24.dp)
            .verticalScroll(scrollState),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        // Header
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            IconButton(onClick = onNavigateHome) {
                Icon(imageVector = Icons.Filled.Home, contentDescription = "Home")
            }
            Text("Timing Drill", style = MaterialTheme.typography.titleLarge)
            Text("") // Spacer
        }

        // Compact Score Display
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            ScoreCard(label = "Score", value = score.toString())
            ScoreCard(label = "Attempts", value = attempts.toString())
            ScoreCard(
                label = "Accuracy",
                value = if (attempts > 0) "${(score * 100 / attempts)}%" else "0%"
            )
        }

        // Mode Selection
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedButton(
                onClick = { currentMode = PracticeMode.DIT },
                modifier = Modifier.weight(1f),
                colors = if (currentMode == PracticeMode.DIT) {
                    androidx.compose.material3.ButtonDefaults.buttonColors()
                } else {
                    androidx.compose.material3.ButtonDefaults.outlinedButtonColors()
                }
            ) {
                Text("Dit (•)")
            }
            OutlinedButton(
                onClick = { currentMode = PracticeMode.DAH },
                modifier = Modifier.weight(1f),
                colors = if (currentMode == PracticeMode.DAH) {
                    androidx.compose.material3.ButtonDefaults.buttonColors()
                } else {
                    androidx.compose.material3.ButtonDefaults.outlinedButtonColors()
                }
            ) {
                Text("Dah (—)")
            }
            OutlinedButton(
                onClick = { currentMode = PracticeMode.BOTH },
                modifier = Modifier.weight(1f),
                colors = if (currentMode == PracticeMode.BOTH) {
                    androidx.compose.material3.ButtonDefaults.buttonColors()
                } else {
                    androidx.compose.material3.ButtonDefaults.outlinedButtonColors()
                }
            ) {
                Text("Both")
            }
        }

        // Instructions
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.secondaryContainer)
        ) {
            Column(modifier = Modifier.padding(12.dp)) {
                Text(
                    text = "Next: ${if (currentTarget == TargetType.DIT) "DIT (•)" else "DAH (—)"}",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.primary
                )
                Text(
                    text = "Tap and hold, release in the GREEN zone!",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }

        // Timing Slider
        val backgroundColor = when (feedback) {
            FeedbackState.Correct -> Color(0xFF4CAF50)
            FeedbackState.Wrong -> Color(0xFFE53935)
            FeedbackState.None -> MaterialTheme.colorScheme.surfaceVariant
        }

        val (greenStart, greenEnd, redEnd) = if (currentTarget == TargetType.DIT) {
            Triple(ditGreenStart, ditGreenEnd, ditRedEnd)
        } else {
            Triple(dahGreenStart, dahGreenEnd, dahRedEnd)
        }

        Box(
            modifier = Modifier
                .fillMaxWidth()
                .height(100.dp)
                .background(backgroundColor, shape = MaterialTheme.shapes.medium)
                .pointerInput(feedback) {
                    if (feedback == FeedbackState.None) {
                        detectTapGestures(
                            onPress = {
                                isPressed = true
                                pressStartTime = System.currentTimeMillis()
                                onKeyDown()

                                // Start slider animation when pressed
                                scope.launch {
                                    sliderPosition.snapTo(1f) // Reset to right
                                    sliderPosition.animateTo(
                                        targetValue = 0f,
                                        animationSpec = tween(
                                            durationMillis = totalSliderTimeMs.toInt(),
                                            easing = LinearEasing
                                        )
                                    )
                                }

                                tryAwaitRelease()

                                // Evaluate on release
                                val pressDuration = System.currentTimeMillis() - pressStartTime
                                val position = 1f - sliderPosition.value // Convert to time-based position

                                isPressed = false
                                onKeyUp()

                                scope.launch {
                                    sliderPosition.stop()

                                    val isInGreenZone = position in greenStart..greenEnd
                                    val isInRedZone = position > greenEnd && position <= redEnd

                                    attempts++
                                    if (isInGreenZone) {
                                        score++
                                        feedback = FeedbackState.Correct
                                    } else {
                                        feedback = FeedbackState.Wrong
                                    }

                                    // Wait for feedback to clear
                                    delay(800)
                                    sliderPosition.snapTo(1f) // Reset to right
                                }
                            }
                        )
                    }
                }
                .drawBehind {
                    val width = size.width
                    val height = size.height

                    // Draw blue zone (safe - too short)
                    drawRect(
                        color = Color(0xFF2196F3),
                        topLeft = Offset(0f, 0f),
                        size = Size(width * (1f - greenStart), height)
                    )

                    // Draw green zone (perfect timing)
                    drawRect(
                        color = Color(0xFF8BC34A),
                        topLeft = Offset(width * (1f - greenEnd), 0f),
                        size = Size(width * (greenEnd - greenStart), height)
                    )

                    // Draw yellow zone (acceptable)
                    drawRect(
                        color = Color(0xFFFFC107),
                        topLeft = Offset(width * (1f - redEnd), 0f),
                        size = Size(width * (redEnd - greenEnd), height)
                    )

                    // Draw red zone (too long)
                    drawRect(
                        color = Color(0xFFF44336),
                        topLeft = Offset(0f, 0f),
                        size = Size(width * (1f - redEnd), height)
                    )

                    // Draw slider position indicator (white bar moving left)
                    val sliderX = width * sliderPosition.value
                    drawRect(
                        color = Color.White,
                        topLeft = Offset(sliderX - 5f, 0f),
                        size = Size(10f, height)
                    )
                },
            contentAlignment = Alignment.Center
        ) {
            if (feedback == FeedbackState.None && !isPressed) {
                Text(
                    "TAP TO START",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = Color.White
                )
            } else if (isPressed) {
                Text(
                    "RELEASE IN GREEN!",
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = Color.White
                )
            }
        }

        // Timing Info
        Card(
            modifier = Modifier.fillMaxWidth(),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
        ) {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(12.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("Dit Target", style = MaterialTheme.typography.labelSmall)
                    Text("${timing.ditMs}ms", style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)
                }
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("Dah Target", style = MaterialTheme.typography.labelSmall)
                    Text("${timing.dahMs}ms", style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)
                }
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    Text("WPM", style = MaterialTheme.typography.labelSmall)
                    Text("${settingsState.wpm}", style = MaterialTheme.typography.titleMedium, fontWeight = FontWeight.Bold)
                }
            }
        }
    }
}

@Composable
private fun ScoreCard(label: String, value: String) {
    Card(
        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.primaryContainer)
    ) {
        Column(
            modifier = Modifier.padding(12.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.labelSmall
            )
            Text(
                text = value,
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Bold
            )
        }
    }
}

private enum class FeedbackState {
    None, Correct, Wrong
}

private enum class TargetType {
    DIT, DAH
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\screens\TimingPracticeScreen.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\theme\Color.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.theme

import androidx.compose.ui.graphics.Color

val MidnightBlue = Color(0xFF0B1026)
val ElectricBlue = Color(0xFF2979FF)
val SoftPurple = Color(0xFF7C4DFF)
val DeepTeal = Color(0xFF00695C)
val SignalGreen = Color(0xFF00C853)

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\theme\Color.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\theme\Theme.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.ColorScheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color

private val DarkColorScheme = darkColorScheme(
    primary = ElectricBlue,
    secondary = SoftPurple,
    tertiary = DeepTeal,
    background = MidnightBlue,
    surface = MidnightBlue,
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFFE3F2FD),
    onSurface = Color(0xFFE3F2FD)
)

private val LightColorScheme = lightColorScheme(
    primary = ElectricBlue,
    secondary = SoftPurple,
    tertiary = DeepTeal,
    background = Color(0xFFF0F3FF),
    surface = Color.White,
    onPrimary = Color.White,
    onSecondary = Color.White,
    onTertiary = Color.White,
    onBackground = Color(0xFF0B1026),
    onSurface = Color(0xFF0B1026)
)

@Composable
fun BruteMorseTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    colorScheme: ColorScheme = if (darkTheme) DarkColorScheme else LightColorScheme,
    content: @Composable () -> Unit
) {
    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\theme\Theme.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\ui\theme\Type.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 48.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.SemiBold,
        fontSize = 24.sp
    ),
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 18.sp
    ),
    labelLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp
    )
)

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\ui\theme\Type.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\viewmodel\ActiveState.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.viewmodel

import com.example.brutemorse.model.PhaseDescriptor

data class CharacterAttempt(
    val expectedChar: String,
    val expectedPattern: String,
    val userPattern: String,
    val isCorrect: Boolean
)

data class ActiveUiState(
    val currentTokens: List<String> = emptyList(),
    val currentPosition: Int = 0,
    val currentInput: String = "",
    val attempts: List<CharacterAttempt> = emptyList(),
    val isReviewMode: Boolean = false,
    val score: Pair<Int, Int> = 0 to 0,
    val phaseDescriptor: PhaseDescriptor? = null,
    val passIndex: Int = 0,
    val totalPasses: Int = 0,
    val stepIndex: Int = 0,
    val totalSteps: Int = 0
)

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\viewmodel\ActiveState.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\viewmodel\PlaybackState.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.viewmodel

import com.example.brutemorse.model.SessionStep
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

data class PlaybackUiState(
    val isPlaying: Boolean = false,
    val currentStep: SessionStep? = null,
    val currentIndex: Int = 0,
    val totalSteps: Int = 0,
    val elapsedMillis: Long = 0L,
    val totalMillis: Long = 0L
)

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\viewmodel\PlaybackState.kt
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\java\com\example\brutemorse\viewmodel\PlaybackViewModel.kt
--------------------------------------------------------------------------------

package com.example.brutemorse.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.example.brutemorse.data.SessionRepository
import com.example.brutemorse.data.SettingsRepository
import com.example.brutemorse.audio.TextToSpeechPlayer
import com.example.brutemorse.audio.MorseInputDetector
import com.example.brutemorse.audio.MorseInputEvent
import com.example.brutemorse.audio.MorseAudioPlayer
import com.example.brutemorse.model.MorseElement
import com.example.brutemorse.model.SpeechElement
import com.example.brutemorse.model.UserSettings
import com.example.brutemorse.model.SessionStep
import com.example.brutemorse.model.ScenarioScript
import com.example.brutemorse.model.MorseDefinitions
import com.example.brutemorse.ui.screens.KeyerTestState
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class PlaybackViewModel(
    private val sessionRepository: SessionRepository,
    private val settingsRepository: SettingsRepository,
    private val context: android.content.Context
) : ViewModel() {

    private val _uiState = MutableStateFlow(PlaybackUiState())
    val uiState: StateFlow<PlaybackUiState> = _uiState.asStateFlow()

    private val _settingsState = MutableStateFlow(UserSettings())
    val settingsState: StateFlow<UserSettings> = _settingsState.asStateFlow()

    private val _activeState = MutableStateFlow(ActiveUiState())
    val activeState: StateFlow<ActiveUiState> = _activeState.asStateFlow()

    private val _keyerTestState = MutableStateFlow(KeyerTestState())
    val keyerTestState: StateFlow<KeyerTestState> = _keyerTestState.asStateFlow()

    val scenarios: List<ScenarioScript> = sessionRepository.scenarios

    private var session: List<SessionStep> = emptyList()
    private var tickerJob: Job? = null
    private var playbackJob: Job? = null
    private var morsePlaybackJob: Job? = null
    private var stepOffsets: List<Long> = emptyList()
    private val audioPlayer = MorseAudioPlayer(context)
    private val ttsPlayer = TextToSpeechPlayer(context)

    // Add separate audio player for Active mode feedback
    private val activeAudioPlayer = MorseAudioPlayer(context)

    private var inputDetector = MorseInputDetector(wpm = 25)
    private var activeSession: List<SessionStep> = emptyList()
    private var currentStepIndex = 0
    private var completionCheckJob: Job? = null
    private var audioInputEnabled = false

    // Keyer test
    private var testInputDetector: MorseInputDetector? = null
    private var testMonitorJob: Job? = null

    // Store completed results history
    private data class CompletedSet(
        val stepIndex: Int,
        val tokens: List<String>,
        val attempts: List<CharacterAttempt>,
        val score: Pair<Int, Int>,
        val descriptor: com.example.brutemorse.model.PhaseDescriptor
    )
    private val completedSets = mutableListOf<CompletedSet>()

    init {
        viewModelScope.launch {
            settingsRepository.settings.collect { settings ->
                _settingsState.value = settings
            }
        }

        // Restore session on app restart
        viewModelScope.launch {
            val savedIndex = settingsRepository.getLastPlaybackIndex()
            if (savedIndex >= 0) {
                // Generate session and restore position
                val settings = settingsState.value
                session = sessionRepository.generateSession(settings)
                val offsets = mutableListOf<Long>()
                var running = 0L
                session.forEach { step ->
                    offsets += running
                    running += step.elements.sumOf { it.durationMillis }
                }
                stepOffsets = offsets

                if (session.isNotEmpty() && savedIndex < session.size) {
                    val restoredElapsed = stepOffsets.getOrNull(savedIndex) ?: 0L
                    _uiState.value = PlaybackUiState(
                        isPlaying = false,
                        currentStep = session.getOrNull(savedIndex),
                        currentIndex = savedIndex,
                        totalSteps = session.size,
                        elapsedMillis = restoredElapsed,
                        totalMillis = running
                    )
                }
            }
        }

        // Restore active session on app restart
        viewModelScope.launch {
            val savedActiveIndex = settingsRepository.getLastActiveIndex()
            if (savedActiveIndex >= 0) {
                val settings = settingsState.value
                activeSession = sessionRepository.generateSession(settings)

                if (activeSession.isNotEmpty() && savedActiveIndex < activeSession.size) {
                    currentStepIndex = savedActiveIndex
                    loadActiveStep(savedActiveIndex, isResume = true)
                }
            }
        }
    }

    fun generateSession() {
        viewModelScope.launch {
            val settings = settingsState.value
            session = sessionRepository.generateSession(settings)
            val offsets = mutableListOf<Long>()
            var running = 0L
            session.forEach { step ->
                offsets += running
                running += step.elements.sumOf { it.durationMillis }
            }
            stepOffsets = offsets
            if (session.isEmpty()) {
                _uiState.value = PlaybackUiState(totalMillis = 0L, totalSteps = 0)
                settingsRepository.saveLastPlaybackIndex(-1) // Clear saved position
                return@launch
            }
            _uiState.value = PlaybackUiState(
                isPlaying = false,  // Start paused so user can press play/resume
                currentStep = session.firstOrNull(),
                currentIndex = 0,
                totalSteps = session.size,
                elapsedMillis = 0L,
                totalMillis = running
            )
            settingsRepository.saveLastPlaybackIndex(0) // Save new starting position
        }
    }

    fun togglePlayback() {
        val current = _uiState.value
        if (current.isPlaying) {
            pause()
        } else {
            play()
        }
    }

    private fun play() {
        if (session.isEmpty()) return
        _uiState.value = _uiState.value.copy(isPlaying = true)
        startPlayback()
    }

    private fun pause() {
        _uiState.value = _uiState.value.copy(isPlaying = false)
        tickerJob?.cancel()
        playbackJob?.cancel()
    }

    fun pausePlayback() {
        pause()
    }

    fun skipNext() {
        if (session.isEmpty()) return
        val nextIndex = (_uiState.value.currentIndex + 1).coerceAtMost(session.lastIndex)
        updateIndex(nextIndex)
        if (_uiState.value.isPlaying) {
            startPlayback()
        }
    }

    fun skipPrevious() {
        if (session.isEmpty()) return
        val previousIndex = (_uiState.value.currentIndex - 1).coerceAtLeast(0)
        updateIndex(previousIndex)
        if (_uiState.value.isPlaying) {
            startPlayback()
        }
    }

    fun skipPhase() {
        if (session.isEmpty()) return
        val currentStep = _uiState.value.currentStep ?: return
        val nextPhaseIndex = session.indexOfFirst { step ->
            step.descriptor.phaseIndex > currentStep.descriptor.phaseIndex
        }
        if (nextPhaseIndex != -1) {
            updateIndex(nextPhaseIndex)
            if (_uiState.value.isPlaying) {
                startPlayback()
            }
        }
    }

    fun restartSubPhase() {
        if (session.isEmpty()) return
        val currentStep = _uiState.value.currentStep ?: return
        val subPhaseStartIndex = session.indexOfFirst { step ->
            step.descriptor.phaseIndex == currentStep.descriptor.phaseIndex &&
                    step.descriptor.subPhaseIndex == currentStep.descriptor.subPhaseIndex
        }
        if (subPhaseStartIndex != -1) {
            updateIndex(subPhaseStartIndex)
            if (_uiState.value.isPlaying) {
                startPlayback()
            }
        }
    }

    fun seekToTime(targetMillis: Long) {
        if (session.isEmpty() || stepOffsets.isEmpty()) return

        // Find the step that contains this time
        val targetIndex = stepOffsets.indexOfLast { offset -> offset <= targetMillis }
            .coerceAtLeast(0)

        updateIndex(targetIndex)
        if (_uiState.value.isPlaying) {
            startPlayback()
        }
    }

    fun jumpToPhase(phaseNumber: Int) {
        if (session.isEmpty()) return
        val phaseStartIndex = session.indexOfFirst { step ->
            step.descriptor.phaseIndex == phaseNumber
        }
        if (phaseStartIndex != -1) {
            updateIndex(phaseStartIndex)
            if (_uiState.value.isPlaying) {
                startPlayback()
            }
        }
    }

    fun jumpToSubPhase(phaseNumber: Int, subPhaseNumber: Int) {
        if (session.isEmpty()) return
        val subPhaseStartIndex = session.indexOfFirst { step ->
            step.descriptor.phaseIndex == phaseNumber &&
                    step.descriptor.subPhaseIndex == subPhaseNumber
        }
        if (subPhaseStartIndex != -1) {
            updateIndex(subPhaseStartIndex)
            if (_uiState.value.isPlaying) {
                startPlayback()
            }
        }
    }

    fun updateSettings(transform: (UserSettings) -> UserSettings) {
        val updated = transform(settingsState.value)
        _settingsState.value = updated
        viewModelScope.launch { sessionRepository.saveSettings(updated) }
    }

    fun playMorsePattern(pattern: String) {
        // Cancel any existing playback first
        morsePlaybackJob?.cancel()

        morsePlaybackJob = viewModelScope.launch {
            try {
                val settings = _settingsState.value
                audioPlayer.playMorsePattern(
                    pattern = pattern,
                    frequencyHz = settings.toneFrequencyHz,
                    wpm = settings.wpm
                )
            } catch (e: Exception) {
                android.util.Log.e("PlaybackViewModel", "Error playing morse pattern", e)
            }
        }
    }

    fun stopMorsePlayback() {
        morsePlaybackJob?.cancel()
        morsePlaybackJob = null
    }

    private fun updateIndex(index: Int) {
        if (session.isEmpty()) return
        playbackJob?.cancel()
        tickerJob?.cancel()
        val newElapsed = stepOffsets.getOrNull(index) ?: 0L
        _uiState.value = _uiState.value.copy(
            currentIndex = index,
            currentStep = session.getOrNull(index),
            elapsedMillis = newElapsed
        )
        // Save position for app restart
        viewModelScope.launch {
            settingsRepository.saveLastPlaybackIndex(index)
        }
    }

    private fun startPlayback() {
        playbackJob?.cancel()
        tickerJob?.cancel()

        // Reset elapsed time to match current step's start position
        val currentStepOffset = stepOffsets.getOrNull(_uiState.value.currentIndex) ?: 0L
        _uiState.value = _uiState.value.copy(elapsedMillis = currentStepOffset)

        tickerJob = viewModelScope.launch {
            while (_uiState.value.isPlaying) {
                delay(100)
                val snapshot = _uiState.value
                val total = snapshot.totalMillis
                if (total == 0L) continue
                val newElapsed = (snapshot.elapsedMillis + 100).coerceAtMost(total)
                val finished = newElapsed >= total
                _uiState.value = snapshot.copy(
                    elapsedMillis = newElapsed,
                    isPlaying = if (finished) false else snapshot.isPlaying
                )
                if (finished) break
            }
        }

        playbackJob = viewModelScope.launch {
            var currentIndex = _uiState.value.currentIndex

            while (currentIndex < session.size && _uiState.value.isPlaying) {
                val step = session[currentIndex]

                for (elementIndex in step.elements.indices) {
                    if (!_uiState.value.isPlaying) break

                    val element = step.elements[elementIndex]

                    _uiState.value = _uiState.value.copy(
                        currentIndex = currentIndex,
                        currentStep = step.copy(
                            elements = listOf(element)
                        )
                    )

                    when (element) {
                        is MorseElement -> {
                            audioPlayer.playMorsePattern(
                                pattern = element.symbol,
                                frequencyHz = element.toneFrequencyHz,
                                wpm = element.wpm
                            )
                        }
                        is SpeechElement -> {
                            ttsPlayer.speak(element.text)
                        }
                        else -> {
                            delay(element.durationMillis)
                        }
                    }
                }

                currentIndex++
                // Save position as we progress
                if (currentIndex < session.size) {
                    settingsRepository.saveLastPlaybackIndex(currentIndex)
                }
            }

            if (_uiState.value.isPlaying) {
                _uiState.value = _uiState.value.copy(isPlaying = false)
            }
        }
    }

    fun generateActiveSession() {
        viewModelScope.launch {
            val settings = settingsState.value
            activeSession = sessionRepository.generateSession(settings)
            currentStepIndex = 0
            completedSets.clear()

            if (activeSession.isEmpty()) {
                _activeState.value = ActiveUiState()
                settingsRepository.saveLastActiveIndex(-1)
                return@launch
            }

            loadActiveStep(0, isResume = false)
            settingsRepository.saveLastActiveIndex(0)
        }
    }

    fun enableAudioInput() {
        try {
            audioInputEnabled = true
            inputDetector.startAudioListening()
        } catch (e: Exception) {
            e.printStackTrace()
            audioInputEnabled = false
        }
    }

    private fun loadActiveStep(index: Int, isResume: Boolean = false) {
        if (index >= activeSession.size) {
            _activeState.value = ActiveUiState()
            if (audioInputEnabled) {
                inputDetector.stopAudioListening()
            }
            viewModelScope.launch {
                settingsRepository.saveLastActiveIndex(-1)
            }
            return
        }

        val step = activeSession[index]
        currentStepIndex = index

        val tokens = step.elements
            .filterIsInstance<MorseElement>()
            .map { it.character }
            .distinct()

        _activeState.value = ActiveUiState(
            currentTokens = tokens,
            currentPosition = 0,
            currentInput = "",
            attempts = emptyList(),
            isReviewMode = false,
            phaseDescriptor = step.descriptor,
            passIndex = step.passIndex,
            totalPasses = step.passCount,
            stepIndex = index,
            totalSteps = activeSession.size
        )

        if (!isResume) {
            startCompletionChecker()
        }

        viewModelScope.launch {
            settingsRepository.saveLastActiveIndex(index)
        }
    }

    fun seekToActiveStep(targetStep: Int) {
        if (activeSession.isEmpty()) return
        val clampedStep = targetStep.coerceIn(0, activeSession.size - 1)
        loadActiveStep(clampedStep, isResume = false)
    }

    fun restartActiveSubPhase() {
        if (activeSession.isEmpty()) {
            // If no active session exists, generate one
            generateActiveSession()
            return
        }

        val currentStep = activeSession.getOrNull(currentStepIndex) ?: return
        val subPhaseStartIndex = activeSession.indexOfFirst { step ->
            step.descriptor.phaseIndex == currentStep.descriptor.phaseIndex &&
                    step.descriptor.subPhaseIndex == currentStep.descriptor.subPhaseIndex
        }
        if (subPhaseStartIndex != -1) {
            loadActiveStep(subPhaseStartIndex, isResume = false)
        }
    }

    fun onActiveKeyDown() {
        inputDetector.onKeyDown()

        // Start playing continuous tone when key is pressed
        val settings = _settingsState.value
        activeAudioPlayer.startContinuousTone(settings.toneFrequencyHz)
    }

    fun onActiveKeyUp() {
        inputDetector.onKeyUp()

        // Stop the tone immediately when key is released
        activeAudioPlayer.stopContinuousTone()

        _activeState.value = _activeState.value.copy(
            currentInput = inputDetector.currentInput.value
        )
    }

    private fun startCompletionChecker() {
        completionCheckJob?.cancel()
        completionCheckJob = viewModelScope.launch {
            while (true) {
                delay(100)
                val state = _activeState.value

                if (!state.isReviewMode) {
                    val isSingleLetterDrill = state.currentTokens.size <= 3 &&
                            state.currentTokens.all { it.length == 1 }

                    val timeoutMs = if (isSingleLetterDrill) 800L else 2500L

                    val event = inputDetector.checkCompletion(completionTimeoutMs = timeoutMs)

                    if (event != null) {
                        handleCharacterComplete(event)
                    }
                }
            }
        }
    }

    private fun handleCharacterComplete(event: MorseInputEvent) {
        val state = _activeState.value
        val expectedChar = state.currentTokens.getOrNull(state.currentPosition) ?: return
        val expectedPattern = MorseDefinitions.morseMap[expectedChar] ?: ""

        val expectedDisplay = expectedPattern.replace(".", "•").replace("-", "—")

        val attempt = CharacterAttempt(
            expectedChar = expectedChar,
            expectedPattern = expectedDisplay,
            userPattern = event.pattern,
            isCorrect = event.pattern == expectedDisplay
        )

        val newAttempts = state.attempts + attempt
        val newPosition = state.currentPosition + 1

        if (newPosition >= state.currentTokens.size) {
            val correct = newAttempts.count { it.isCorrect }
            val total = newAttempts.size

            val completed = CompletedSet(
                stepIndex = currentStepIndex,
                tokens = state.currentTokens,
                attempts = newAttempts,
                score = correct to total,
                descriptor = state.phaseDescriptor!!
            )
            completedSets.add(completed)

            _activeState.value = state.copy(
                attempts = newAttempts,
                isReviewMode = true,
                score = correct to total,
                currentInput = ""
            )

            completionCheckJob?.cancel()
        } else {
            _activeState.value = state.copy(
                currentPosition = newPosition,
                currentInput = "",
                attempts = newAttempts
            )
            inputDetector.reset()
        }
    }

    fun onActiveNextSet() {
        loadActiveStep(currentStepIndex + 1, isResume = false)
    }

    fun onActiveBackToResults() {
        if (completedSets.size >= 2) {
            completedSets.removeLastOrNull()

            val previousSet = completedSets.lastOrNull()
            if (previousSet != null) {
                currentStepIndex = previousSet.stepIndex
                _activeState.value = ActiveUiState(
                    currentTokens = previousSet.tokens,
                    currentPosition = previousSet.tokens.size,
                    currentInput = "",
                    attempts = previousSet.attempts,
                    isReviewMode = true,
                    score = previousSet.score,
                    phaseDescriptor = previousSet.descriptor,
                    passIndex = previousSet.descriptor.phaseIndex,
                    totalPasses = activeSession.size
                )
            }
        }
    }

    fun jumpToPhaseActive(phaseNumber: Int) {
        if (activeSession.isEmpty()) return
        val phaseStartIndex = activeSession.indexOfFirst { step ->
            step.descriptor.phaseIndex == phaseNumber
        }
        if (phaseStartIndex != -1) {
            loadActiveStep(phaseStartIndex, isResume = false)
        }
    }

    fun jumpToSubPhaseActive(phaseNumber: Int, subPhaseNumber: Int) {
        if (activeSession.isEmpty()) return
        val subPhaseStartIndex = activeSession.indexOfFirst { step ->
            step.descriptor.phaseIndex == phaseNumber &&
                    step.descriptor.subPhaseIndex == subPhaseNumber
        }
        if (subPhaseStartIndex != -1) {
            loadActiveStep(subPhaseStartIndex, isResume = false)
        }
    }

    fun startKeyerTest(sensitivity: Float) {
        testInputDetector?.stopAudioListening()
        testInputDetector = MorseInputDetector(wpm = 25).apply {
            updateSensitivity(sensitivity)
        }

        _keyerTestState.value = KeyerTestState(isListening = true)

        try {
            testInputDetector?.startAudioListening()
            startKeyerTestMonitoring()
        } catch (e: Exception) {
            android.util.Log.e("PlaybackViewModel", "Failed to start keyer test", e)
            _keyerTestState.value = KeyerTestState(isListening = false)
        }
    }

    fun stopKeyerTest() {
        testMonitorJob?.cancel()
        testInputDetector?.stopAudioListening()
        testInputDetector = null
        _keyerTestState.value = KeyerTestState(isListening = false)
    }

    private fun startKeyerTestMonitoring() {
        testMonitorJob?.cancel()
        testMonitorJob = viewModelScope.launch {
            var detectionCount = 0
            while (_keyerTestState.value.isListening) {
                delay(50)

                val detector = testInputDetector ?: break
                val audioMetrics = detector.getAudioMetrics()

                _keyerTestState.value = _keyerTestState.value.copy(
                    currentRMS = audioMetrics.currentRMS,
                    noiseFloor = audioMetrics.noiseFloor,
                    threshold = audioMetrics.threshold,
                    isKeyDown = audioMetrics.isKeyDown,
                    currentInput = detector.currentInput.value
                )

                val event = detector.checkCompletion(completionTimeoutMs = 800L)
                if (event != null) {
                    detectionCount++
                    _keyerTestState.value = _keyerTestState.value.copy(
                        lastDetection = "${event.pattern} = ${event.character ?: "?"}",
                        detectionCount = detectionCount
                    )
                }
            }
        }
    }

    override fun onCleared() {
        super.onCleared()
        tickerJob?.cancel()
        playbackJob?.cancel()
        morsePlaybackJob?.cancel()
        completionCheckJob?.cancel()
        testMonitorJob?.cancel()
        audioPlayer.release()
        activeAudioPlayer.release()
        ttsPlayer.release()
        if (audioInputEnabled) {
            inputDetector.stopAudioListening()
        }
        testInputDetector?.stopAudioListening()
    }
}

class PlaybackViewModelFactory(
    private val sessionRepository: SessionRepository,
    private val settingsRepository: SettingsRepository,
    private val context: android.content.Context
) : ViewModelProvider.Factory {
    override fun <T : ViewModel> create(modelClass: Class<T>): T {
        if (modelClass.isAssignableFrom(PlaybackViewModel::class.java)) {
            @Suppress("UNCHECKED_CAST")
            return PlaybackViewModel(sessionRepository, settingsRepository, context) as T
        }
        throw IllegalArgumentException("Unknown ViewModel class")
    }
}

--------------------------------------------------------------------------------
END OF FILE: app\src\main\java\com\example\brutemorse\viewmodel\PlaybackViewModel.kt
--------------------------------------------------------------------------------


================================================================================
RESOURCES
================================================================================
Files in this section: 5
================================================================================


--------------------------------------------------------------------------------
FILE: app\src\main\res\drawable\ic_notification.xml
--------------------------------------------------------------------------------

<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path
        android:fillColor="#000000"
        android:pathData="M12,22c1.1,0 2,-0.9 2,-2h-4c0,1.1 0.9,2 2,2zM18,16v-5c0,-3.07 -1.63,-5.64 -4.5,-6.32V4c0,-0.83 -0.67,-1.5 -1.5,-1.5S10.5,3.17 10.5,4v0.68C7.64,5.36 6,7.92 6,11v5l-2,2v1h16v-1l-2,-2z"/>
</vector>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\res\drawable\ic_notification.xml
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\res\values\strings.xml
--------------------------------------------------------------------------------

<resources>
    <string name="app_name">Brute Morse Immersion</string>
</resources>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\res\values\strings.xml
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\res\values\themes.xml
--------------------------------------------------------------------------------

<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.BruteMorse" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowActionBar">false</item>
        <item name="android:statusBarColor" tools:targetApi="l">@android:color/transparent</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@android:color/white</item>
    </style>
</resources>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\res\values\themes.xml
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\res\values\themes_material3_compat.xml
--------------------------------------------------------------------------------

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Provide NoActionBar variants for Material3 themes when the library is missing them. -->
    <style name="Theme.Material3.DayNight.NoActionBar" parent="Theme.Material3.DayNight">
        <item name="android:windowActionBar">false</item>
        <item name="android:windowNoTitle">true</item>
    </style>

    <style name="Theme.Material3.Dark.NoActionBar" parent="Theme.Material3.DayNight.NoActionBar" />
</resources>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\res\values\themes_material3_compat.xml
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\src\main\res\values-night\themes.xml
--------------------------------------------------------------------------------

<resources xmlns:tools="http://schemas.android.com/tools">
    <style name="Theme.BruteMorse" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:windowNoTitle">true</item>
        <item name="android:windowActionBar">false</item>
        <item name="android:statusBarColor" tools:targetApi="l">@android:color/transparent</item>
        <item name="android:navigationBarColor" tools:targetApi="l">@android:color/black</item>
    </style>
</resources>

--------------------------------------------------------------------------------
END OF FILE: app\src\main\res\values-night\themes.xml
--------------------------------------------------------------------------------


================================================================================
DOCUMENTATION
================================================================================
Files in this section: 1
================================================================================


--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------

# Brute Morse Code Android App

## Overview
Brute Morse Code is a passive immersion Android training application designed to drill Morse code proficiency through hours-long listening sessions. Users configure a session once, press play, and let the curated audio program cycle through mathematically generated patterns and real-world communication scenarios. The goal is effortless exposure rather than interactive drills or scoring.

## Core Philosophy
- **Passive consumption**: The app acts as an automated instructor that plays structured Morse code sessions for 2–7 hours without requiring user input.
- **Mathematical coverage**: Carefully designed traversal patterns ensure that every character, digraph, and phrase receives repeated exposure without predictable loops.
- **Progressive difficulty**: Training begins with single characters and builds toward realistic amateur radio QSOs with minimal vocal support.
- **Set-and-forget experience**: After initial configuration, autoplay advances through all phases, remembers progress, and resumes playback after interruptions.

## Mathematical Learning Patterns
### 1. NestedID (Nested Incremental–Decremental)
- Forward pass: `A`, `AB`, `ABC`, …, `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
- Reverse pass: `Z`, `ZY`, `ZYX`, …, `ZYXWVUTSRQPONMLKJIHGFEDCBA`
- Provides contextual repetition while covering the full alphabet in both directions.

### 2. BCT (Balanced Coprime Traversal)
The traversal index is calculated with:

```
position = (c + d * a * sign * offset) % n
```

Where:
- `c`: center position
- `d`: direction (`±1`)
- `a`: coprime step value
- `n`: size of the active set
- `offset = ceil(i / 2)`
- `sign = (-1)^(i + 1)`

This generates 26 or more passes through a character set while avoiding habituation by hopping across indices using coprime values.

### 3. ARM1V (Active Recall Morse 1 Vocal)
- Progressive repetition sequences: `[morse×1, speak]`, `[morse×2, speak]`, `[morse×3, speak]`, `[morse×4, speak]`
- Delayed recall: `[morse … 500 ms pause … speak]`
- Text-to-speech (TTS) announces letters/numbers after Morse playback, reinforcing recognition and recall.

### 4. ProgressiveBuild
- Builds words step by step (e.g., `A → AN → ANT → ANTE → ANTEN → ANTENN → ANTENNA`).
- Utilizes ham radio vocabulary, Q-codes, and common digraphs (`TH`, `AN`, `ER`, `ON`, etc.).

### 5. TongueTwister
- Presents rapid sequences of easily confused elements to sharpen discrimination.
- Confusion sets include letters (e.g., `[E, I, S, H]`), numbers/letters (e.g., `[5, S, H]`), and mixed Morse terms (`[CQ, QRZ, QTH]`, `[73, 88, SK]`).
- Vocal support transitions from full → delayed → sparse → none.

## User Interface
### Main Listening Screen
- Header: “≡ Listen” with hamburger menu for settings.
- Status text: `[Phase 1.2, BCT Pattern]` and a session timer (e.g., `2:47:33 / 7:00:00`).
- Central visualizer showing the current Morse pattern (animated dits/dahs) and the character being transmitted.
- Progress bar for the active pattern with pass indicators (e.g., `Phase 1.2 – Pass 14/26`).
- Playback controls: skip backward 30 s, play/pause, skip forward 30 s, skip to next pattern/phase.
- Additional info: current WPM, auto-play indicator, next phase preview.

### Additional Screens
1. **Initial Setup**: Collects call signs, playback preferences (WPM, tone, volume, TTS voice), and phase selection. Defaults to all phases enabled for a 7-hour session.
2. **Main Listening**: The core experience with autoplay, background playback, lock-screen controls, and persistence.
3. **Settings**: Minimal adjustments for WPM, tone, volume, TTS, call signs, progress reset, theme selection, and screen-on toggle.
4. **Scenario Library**: Lists QSO scenarios for Phase 4 (normal QSOs, SKYWARN events, apocalypse situations) and supports custom additions.

## Training Session Flow
1. **Phase 1: Alphabet Mastery (~90 min)**
   - 1.1 NestedID alphabet repetitions
   - 1.2 BCT traversal with ARM1V (26 passes, 4 repetitions per letter)
   - 1.3 Common digraphs with ProgressiveBuild
   - 1.4 Letter confusion TongueTwisters with varying vocal support

2. **Phase 2: Expanded Set (~120 min)**
   - 2.1 Numbers 0–9 with NestedID + ARM1V
   - 2.2 Full BCT across letters, numbers, and radio phrases
   - 2.3 Number/letter confusion TongueTwisters
   - 2.4 Number sequences (signal reports, frequencies)

3. **Phase 3: Words & Abbreviations (~90 min)**
   - 3.1 Ham vocabulary introduction (50+ terms)
   - 3.2 Q-code TongueTwisters
   - 3.3 Reduced vocal support (2:1 Morse-to-vocal ratio)
   - 3.4 Mixed confusion sets

4. **Phase 4: Real-World QSOs (~120 min)**
   - 4.0 Vocabulary review (80 % Morse-only, 20 % vocal)
   - 4.1–4.4 Normal rag-chew QSOs
   - 4.5–4.8 SKYWARN emergency scenarios
   - 4.9–4.12 Apocalypse scenarios

Each phase transition includes a 2-second chime and a TTS announcement (e.g., “Phase 2 complete. Beginning Phase 3: Words and Abbreviations”). Sessions can loop back to Phase 1 after completion.

## Audio & Timing Requirements
- Pure sine wave tone, default 800 Hz (configurable 400–1200 Hz).
- Paris standard timing:
  - `unit = 1200 ms / WPM`
  - dit = 1 unit, dah = 3 units
  - intra-character gap = 1 unit, inter-character gap = 3 units, inter-word gap = 7 units
- Android TTS provides delayed vocalizations for ARM1V.
- Audio assets (e.g., individual letters, numbers, magnitudes) can reside under an `audio/` directory.

## Technical Implementation Notes
- Foreground service ensures uninterrupted background playback with MediaSession integration for lock-screen controls.
- Partial wake lock prevents sleep during active playback.
- Audio focus handling pauses playback during interruptions (e.g., phone calls) and resumes automatically.
- Session state persists via `SharedPreferences`, storing call signs, WPM, phase selections, and current playback position (e.g., `{ phase: 2, subphase: 3, pattern_pass: 14, element_index: 127 }`).
- State is saved every 60 seconds and restored on launch with a resume prompt.
- Optional dark/light theme support and a “keep screen on” setting.

## Pattern Generation Example (Kotlin)
```kotlin
fun generateCompleteTrainingSession(): List<AudioSegment> {
    val session = mutableListOf<AudioSegment>()

    if (phase1Selected) session.addAll(generatePhase1())
    if (phase2Selected) session.addAll(generatePhase2())
    if (phase3Selected) session.addAll(generatePhase3())
    if (phase4Selected) session.addAll(generatePhase4())

    return session
}

fun bctTraversal(center: Int, size: Int, direction: Int, coprime: Int): List<Int> {
    val sequence = mutableListOf<Int>()
    for (i in 0 until size) {
        val offset = ceil(i / 2.0).toInt()
        val sign = if ((i + 1) % 2 == 0) -1 else 1
        val position = (center + direction * coprime * sign * offset).mod(size)
        sequence.add(position)
    }
    return sequence
}
```

## Scenario Template System
- Variables support runtime substitution during Phase 4 playback:
  - `{MY_CALL}`: user call sign
  - `{FRIEND_CALL}`: rotates through friend call signs
  - `{MY_QTH}`: random city/state
  - `{SIGNAL}`: random signal report (`599`, `579`, etc.)
  - `{WX}`: random weather condition
  - `{FREQ}`: random operating frequency
  - `{RIG}`: random radio model
  - `{PWR}`: random transmit power

### Example Templates
**Normal Rag-Chew**
```
CQ CQ CQ DE {MY_CALL} {MY_CALL} K
{MY_CALL} DE {FRIEND_CALL} UR {SIGNAL} QTH {MY_QTH} K
{FRIEND_CALL} DE {MY_CALL} R R UR {SIGNAL} QTH TEXAS WX {WX} RIG {RIG} K
{MY_CALL} DE {FRIEND_CALL} R R FB OM PWR {PWR} 73 SK
```

**SKYWARN**
```
NET CONTROL DE {MY_CALL} TORNADO SPOTTED 5 MILES WEST OF {MY_QTH} MOVING NORTHEAST K
{MY_CALL} DE NET CONTROL ROGER RELAY TO NWS CONTINUE REPORTS K
```

**Apocalypse**
```
ANY STATION DE {MY_CALL} EMERGENCY TRAFFIC GRID DOWN NEED SUPPLY INFO K
{MY_CALL} DE {FRIEND_CALL} COPY EMERGENCY SAFE ZONE AT {MY_QTH} FOOD WATER AVAILABLE K
```

## Exclusions (Intentional)
The initial release deliberately omits features such as feedback, scoring, gamification, social sharing, progress analytics, or active Morse sending. The experience is entirely passive listening.

## Example User Journey
1. Download the app and complete initial setup.
2. Listen to Phase 1 in bed for ~2 hours; session auto-saves when stopping.
3. Resume during a commute to progress through Phase 2.
4. Finish remaining phases over subsequent sessions, ultimately achieving 25 WPM comprehension through sustained immersion.

## Roadmap Considerations
- Automated audio generation pipeline for all patterns.
- Downloadable scenario packs or community submissions.
- Advanced analytics (time spent per phase, repetition counts).
- Optional interactive mode for active recall once immersion mastery is achieved.


## Current Implementation
The repository now contains a Jetpack Compose Android application that models the complete brute-force training session described above. Highlights:

- **Autogenerated training queue**: `SessionRepository` deterministically builds every phase, sub-phase, and pass using the NestedID, BCT, ProgressiveBuild, and TongueTwister patterns.
- **Scenario templating**: Phase 4 scripts substitute `{MY_CALL}`, `{FRIEND_CALL}`, `{MY_QTH}`, and related tokens with rotating context drawn from user preferences and curated data pools.
- **Composable UI surfaces**: Setup, Listening, Settings, and Scenario Library screens match the passive-immersion workflow with Material Design 3 styling.
- **State management**: `PlaybackViewModel` coordinates DataStore-backed settings, generates long-form sessions, and simulates long-running playback progress that can auto-advance across passes and phases.
- **Foreground playback scaffolding**: `PlaybackService` establishes a MediaSession-ready foreground service for future real audio rendering while keeping notification controls alive during background playback.

## Developer Quickstart
1. Open the project in Android Studio Hedgehog or newer.
2. Let Gradle sync; the wrapper scripts will fetch the Gradle JAR automatically (requires curl/wget on macOS/Linux or PowerShell on Windows).
3. Select the `app` configuration and deploy to an emulator or device running Android 8.0 (API 26) or later.
4. On first launch, enter your call sign, optional friends, confirm the default phase selection, and tap **START TRAINING** to generate a 7-hour passive session.
5. Use the Listen screen’s controls to simulate playback, skip passes, and inspect future phases or scenario scripts.

## Next Steps
- Replace the simulated playback ticker with synthesized Morse audio using the configured WPM and tone frequency.
- Drive the `PlaybackService` with actual ExoPlayer media items per `SessionStep`, piping tone generation and TTS into the audio timeline.
- Persist fine-grained resume points (phase, pass, element) so sessions can resume exactly where users paused.
- Expand the scenario library and allow custom user-defined templates stored in DataStore or a lightweight database.

--------------------------------------------------------------------------------
END OF FILE: README.md
--------------------------------------------------------------------------------


================================================================================
SUMMARY
================================================================================

Total files included: 39

Breakdown by category:
- Manifest files:     1
- Gradle files:       4
- Source files:       28
- Resource files:     5
- Documentation:      1

================================================================================
END OF SOURCE CODE LISTING
================================================================================

INSTRUCTIONS FOR CLAUDE:
This is a complete source code listing of the Brute Morse Code Android app.
The app is an educational morse code training application using:
- Kotlin with Jetpack Compose
- MVVM architecture
- Custom audio generation for morse code
- Multiple learning algorithms (BCT, ARM1V, NestedID, etc.)

Key areas of focus:
1. audio/ - Morse code audio generation and playback
2. model/ - Learning algorithms and data structures
3. viewmodel/ - UI state management
4. ui/screens/ - User interface screens

Please review and provide analysis, suggestions, or answers to questions
about this codebase.
